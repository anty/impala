From d902c13c06640a5c901e9804b7b6ad3f7792406f Mon Sep 17 00:00:00 2001
From: Shreepadma Venugopalan <shreepadma@cloudera.com>
Date: Tue, 5 Mar 2013 11:53:09 -0800
Subject: [PATCH 070/121] CDH-8626. Support for HS2 in memory log capture and retrieval

---
 .../java/org/apache/hadoop/hive/conf/HiveConf.java |    2 +
 conf/hive-default.xml.template                     |   16 +
 .../java/org/apache/hive/jdbc/HiveStatement.java   |   21 +
 .../test/org/apache/hive/jdbc/TestJdbcDriver2.java |   85 ++-
 service/if/TCLIService.thrift                      |   18 +
 service/src/gen/thrift/gen-cpp/TCLIService.cpp     |  274 +++++++
 service/src/gen/thrift/gen-cpp/TCLIService.h       |  127 +++
 .../thrift/gen-cpp/TCLIService_server.skeleton.cpp |    5 +
 .../src/gen/thrift/gen-cpp/TCLIService_types.cpp   |  144 ++++
 service/src/gen/thrift/gen-cpp/TCLIService_types.h |   81 ++
 .../hive/service/cli/thrift/TCLIService.java       |  806 ++++++++++++++++++++
 .../service/cli/thrift/TExecuteStatementReq.java   |    4 +-
 .../apache/hive/service/cli/thrift/TGetLogReq.java |  390 ++++++++++
 .../hive/service/cli/thrift/TGetLogResp.java       |  491 ++++++++++++
 .../hive/service/cli/thrift/TOpenSessionReq.java   |    4 +-
 .../hive/service/cli/thrift/TOpenSessionResp.java  |    4 +-
 .../hive/service/cli/thrift/TStructTypeEntry.java  |    4 +-
 .../hive/service/cli/thrift/TUnionTypeEntry.java   |    4 +-
 service/src/gen/thrift/gen-php/TCLIService.php     |  206 +++++
 .../thrift/gen-py/TCLIService/TCLIService-remote   |    7 +
 .../gen/thrift/gen-py/TCLIService/TCLIService.py   |  170 ++++
 .../src/gen/thrift/gen-py/TCLIService/ttypes.py    |  140 ++++
 service/src/gen/thrift/gen-rb/t_c_l_i_service.rb   |   54 ++
 .../src/gen/thrift/gen-rb/t_c_l_i_service_types.rb |   37 +
 .../org/apache/hive/service/cli/CLIService.java    |   68 ++-
 .../apache/hive/service/cli/CLIServiceClient.java  |    3 +
 .../hive/service/cli/EmbeddedCLIServiceClient.java |    5 +
 .../org/apache/hive/service/cli/ICLIService.java   |    5 +-
 .../hive/service/cli/log/LinkedStringBuffer.java   |   80 ++
 .../hive/service/cli/log/LogDivertAppender.java    |   91 +++
 .../apache/hive/service/cli/log/LogManager.java    |  184 +++++
 .../apache/hive/service/cli/log/OperationLog.java  |   92 +++
 .../cli/operation/AsyncExecStmtOperation.java      |   32 +-
 .../service/cli/operation/OperationManager.java    |   11 +-
 .../hive/service/cli/session/HiveSession.java      |    7 +
 .../hive/service/cli/session/HiveSessionImpl.java  |  129 +++-
 .../cli/session/HiveSessionImplwithUGI.java        |    2 -
 .../hive/service/cli/session/SessionManager.java   |   13 +
 .../hive/service/cli/thrift/ThriftCLIService.java  |   17 +-
 .../service/cli/thrift/ThriftCLIServiceClient.java |   15 +
 40 files changed, 3774 insertions(+), 74 deletions(-)
 create mode 100644 service/src/gen/thrift/gen-javabean/org/apache/hive/service/cli/thrift/TGetLogReq.java
 create mode 100644 service/src/gen/thrift/gen-javabean/org/apache/hive/service/cli/thrift/TGetLogResp.java
 create mode 100644 service/src/java/org/apache/hive/service/cli/log/LinkedStringBuffer.java
 create mode 100644 service/src/java/org/apache/hive/service/cli/log/LogDivertAppender.java
 create mode 100644 service/src/java/org/apache/hive/service/cli/log/LogManager.java
 create mode 100644 service/src/java/org/apache/hive/service/cli/log/OperationLog.java

diff --git a/src/common/src/java/org/apache/hadoop/hive/conf/HiveConf.java b/src/common/src/java/org/apache/hadoop/hive/conf/HiveConf.java
index 36af5d6..65021e5 100644
--- a/src/common/src/java/org/apache/hadoop/hive/conf/HiveConf.java
+++ b/src/common/src/java/org/apache/hadoop/hive/conf/HiveConf.java
@@ -694,6 +694,8 @@ public class HiveConf extends Configuration {
     HIVE_SERVER2_KERBEROS_IMPERSONATION("hive.server2.enable.impersonation", false),
     HIVE_SERVER2_CUSTOM_AUTHENTICATION_CLASS("hive.server2.custom.authentication.class", null),
     HIVE_SERVER2_BLOCKING_QUERY("hive.server2.blocking.query", true),
+    HIVE_SERVER2_IN_MEM_LOGGING("hive.server2.in.mem.logging", true),
+    HIVE_SERVER2_IN_MEM_LOG_SIZE("hive.server2.in.mem.log.size", 128 * 1024),
 
     HIVE_CONF_RESTRICTED_LIST("hive.conf.restricted.list", null),
 
diff --git a/src/conf/hive-default.xml.template b/src/conf/hive-default.xml.template
index c337160..04bb6b6 100644
--- a/src/conf/hive-default.xml.template
+++ b/src/conf/hive-default.xml.template
@@ -1701,6 +1701,22 @@
 </property>
 
 <property>
+  <name>hive.server2.in.mem.logging</name>
+  <value>true</value>
+  <description>
+    Whether to turn on hiveserver2 in memory logging
+  </description>
+</property>
+
+<property>
+  <name>hive.server2.in.mem.log.size</name>
+  <value>131072</value>
+  <description>
+    Maximum size of the hiveserver2 in memory query log. Note that the size is per query.
+  </description>
+</property>
+
+<property>
   <name>hive.decode.partition.name</name>
   <value>false</value>
   <description>Whether to show the unquoted partition names in query results.</description>
diff --git a/src/jdbc/src/java/org/apache/hive/jdbc/HiveStatement.java b/src/jdbc/src/java/org/apache/hive/jdbc/HiveStatement.java
index 61419f4..599dc73 100644
--- a/src/jdbc/src/java/org/apache/hive/jdbc/HiveStatement.java
+++ b/src/jdbc/src/java/org/apache/hive/jdbc/HiveStatement.java
@@ -32,6 +32,8 @@ import org.apache.hive.service.cli.thrift.TCloseOperationReq;
 import org.apache.hive.service.cli.thrift.TCloseOperationResp;
 import org.apache.hive.service.cli.thrift.TExecuteStatementReq;
 import org.apache.hive.service.cli.thrift.TExecuteStatementResp;
+import org.apache.hive.service.cli.thrift.TGetLogReq;
+import org.apache.hive.service.cli.thrift.TGetLogResp;
 import org.apache.hive.service.cli.thrift.TOperationHandle;
 import org.apache.hive.service.cli.thrift.TSessionHandle;
 import org.apache.hive.service.cli.thrift.TStatusCode;
@@ -286,6 +288,25 @@ public class HiveStatement implements java.sql.Statement {
     throw new SQLException("Method not supported");
   }
 
+  public String getLog() throws SQLException {
+    if (isClosed) {
+      throw new SQLException("Can't get log for statement after statement has been closed");
+    }
+
+    TGetLogReq getLogReq = new TGetLogReq();
+    TGetLogResp getLogResp;
+    getLogReq.setOperationHandle(stmtHandle);
+    try {
+      getLogResp = client.GetLog(getLogReq);
+      Utils.verifySuccessWithInfo(getLogResp.getStatus());
+    } catch (SQLException e) {
+      throw e;
+    } catch (Exception e) {
+      throw new SQLException(e.toString(), "08S01", e);
+    }
+    return getLogResp.getLog();
+  }
+
   /*
    * (non-Javadoc)
    *
diff --git a/src/jdbc/src/test/org/apache/hive/jdbc/TestJdbcDriver2.java b/src/jdbc/src/test/org/apache/hive/jdbc/TestJdbcDriver2.java
index aa9704b..8550457 100644
--- a/src/jdbc/src/test/org/apache/hive/jdbc/TestJdbcDriver2.java
+++ b/src/jdbc/src/test/org/apache/hive/jdbc/TestJdbcDriver2.java
@@ -597,6 +597,30 @@ public class TestJdbcDriver2 extends TestCase {
         exceptionFound);
   }
 
+  public void testGetLog() throws Exception {
+    HiveStatement stmt = (HiveStatement)con.createStatement();
+    assertNotNull("Statement is null", stmt);
+
+    ResultSet res = stmt.executeQuery("select count(*) from " + tableName);
+    ResultSetMetaData meta = res.getMetaData();
+
+    boolean moreRow = res.next();
+    while (moreRow) {
+      try {
+        moreRow = res.next();
+      } catch (SQLException e) {
+        throw e;
+      }
+    }
+
+    String log = stmt.getLog();
+    assertTrue("Operation Log looks incorrect" ,
+        log.contains("Parsing command: select count(*) from testHiveJdbcDriver_Table"));
+    assertTrue("Operation Log looks incorrect",
+        log.contains( "select count(*) from testHiveJdbcDriver_Table"));
+
+  }
+
   public void testShowTables() throws SQLException {
     Statement stmt = con.createStatement();
     assertNotNull("Statement is null", stmt);
@@ -1294,13 +1318,13 @@ public class TestJdbcDriver2 extends TestCase {
    */
   public void testAsyncQuery() throws SQLException {
     String fooQueryTag = "foo";
-    Statement stmt = con.createStatement();
+    HiveStatement stmt = (HiveStatement)con.createStatement();
     stmt.execute("set hive.server2.blocking.query=false");
     stmt.close();
-    stmt = con.createStatement();
+    stmt = (HiveStatement)con.createStatement();
     stmt.execute("set hive.exec.post.hooks = org.apache.hive.jdbc.TestJdbcDriver2$QueryBlockHook");
     stmt.close();
-    stmt = con.createStatement();
+    stmt = (HiveStatement)con.createStatement();
     stmt.execute("set " + QueryTag + " = " + fooQueryTag);
     QueryBlockHook.setupBlock(fooQueryTag);
     ResultSet res = stmt.executeQuery("select c1 from " + dataTypeTableName +
@@ -1317,6 +1341,15 @@ public class TestJdbcDriver2 extends TestCase {
       // verify that the fetch fails with query still running error
       assertEquals("HY010", e.getSQLState());
     }
+
+    //test log retrieval
+    String log = stmt.getLog();
+    assertTrue(log.length() > 1);
+    assertTrue("Operation log looks incorrect",
+        log.contains("Parsing command: select c1 from testDataTypeTable where c1 = 1"));
+    assertTrue("Operation log looks incorrect",
+        log.contains("Starting command: select c1 from testDataTypeTable where c1 = 1"));
+
     QueryBlockHook.clearBlock(fooQueryTag); // continue query
     // verify that we can now fetch data
     // the query could be still be running and might take a few more iteration to finish
@@ -1334,6 +1367,12 @@ public class TestJdbcDriver2 extends TestCase {
       }
     } while (true);
     assertEquals(1, res.getInt(1));
+
+    log = stmt.getLog();
+    assertTrue(log.length() > 1);
+    assertTrue("Operation log looks incorrect",
+        log.contains("Execution completed successfully"));
+
     stmt.close();
   }
 
@@ -1348,15 +1387,15 @@ public class TestJdbcDriver2 extends TestCase {
     String fooQueryTag = "foo";
     String barQueryTag = "bar";
 
-    Statement stmt = con.createStatement();
+    HiveStatement stmt = (HiveStatement)con.createStatement();
     stmt.execute("set hive.server2.blocking.query=false");
     stmt.close();
-    stmt = con.createStatement();
+    stmt = (HiveStatement)con.createStatement();
     stmt.execute("set hive.exec.post.hooks = org.apache.hive.jdbc.TestJdbcDriver2$QueryBlockHook");
     stmt.close();
 
     // start foo query
-    stmt = con.createStatement();
+    stmt = (HiveStatement)con.createStatement();
     stmt.execute("set " + QueryTag + " = " + fooQueryTag);
     QueryBlockHook.setupBlock(fooQueryTag);
     ResultSet res = stmt.executeQuery("select c1 from " + dataTypeTableName +
@@ -1375,16 +1414,16 @@ public class TestJdbcDriver2 extends TestCase {
     }
 
     // start bar query
-    Statement stmt2 = con.createStatement();
+    HiveStatement stmt2 = (HiveStatement)con.createStatement();
     stmt2.execute("set " + QueryTag + " = " + barQueryTag);
     QueryBlockHook.setupBlock(barQueryTag);
-    ResultSet res2 = stmt2.executeQuery("select c1 from " + dataTypeTableName +
+    ResultSet res2 = stmt2.executeQuery("select c3 from " + dataTypeTableName +
     " where c1 = 1");
     assertNotNull(stmt2.getWarnings());
     ResultSetMetaData md2 = res2.getMetaData();
     // sanity check metadata
     assertEquals(md2.getColumnCount(), 1); // only one result column
-    assertEquals(md2.getColumnLabel(1), "c1" ); // verify the column name
+    assertEquals(md2.getColumnLabel(1), "c3" ); // verify the column name
     try {
       res2.next();
       assertTrue(false);
@@ -1393,6 +1432,14 @@ public class TestJdbcDriver2 extends TestCase {
       assertEquals("HY010", e.getSQLState());
     }
 
+    //test log retrieval
+    String log = stmt.getLog();
+    assertTrue(log.length() > 1);
+    assertTrue("Operation log looks incorrect",
+        log.contains("Parsing command: select c1 from testDataTypeTable where c1 = 1"));
+    assertTrue("Operation log looks incorrect",
+        log.contains("Starting command: select c1 from testDataTypeTable where c1 = 1"));
+
     QueryBlockHook.clearBlock(fooQueryTag); // continue foo query
     // verify that we can now fetch data
     // the query could be still be running and might take a few more iteration to finish
@@ -1409,7 +1456,12 @@ public class TestJdbcDriver2 extends TestCase {
         }
       }
     } while (true);
-    assertEquals(1, res.getInt(1));
+
+    //get log again
+    log = stmt.getLog();
+    assertTrue(log.length() > 1);
+    assertTrue("Operation log looks incorrect",
+        log.contains("Execution completed successfully"));
     stmt.close();
 
     // verify that the bar query is still blocked
@@ -1421,6 +1473,14 @@ public class TestJdbcDriver2 extends TestCase {
       assertEquals("HY010", e.getSQLState());
     }
 
+   //test log retrieval
+   log = stmt2.getLog();
+   assertTrue(log.length() > 1);
+   assertTrue("Operation log looks incorrect",
+        log.contains("Parsing command: select c3 from testDataTypeTable where c1 = 1"));
+   assertTrue("Operation log looks incorrect",
+        log.contains("Starting command: select c3 from testDataTypeTable where c1 = 1"));
+
     QueryBlockHook.clearBlock(barQueryTag); // continue bar query
     // verify that we can now fetch data for bar query
     // the query could be still be running and might take a few more iteration to finish
@@ -1438,6 +1498,11 @@ public class TestJdbcDriver2 extends TestCase {
       }
     } while (true);
     assertEquals(1, res2.getInt(1));
+    //get log again
+    log = stmt2.getLog();
+    assertTrue(log.length() > 1);
+    assertTrue("Operation log looks incorrect",
+        log.contains("Execution completed successfully"));
     stmt2.close();
   }
 
diff --git a/src/service/if/TCLIService.thrift b/src/service/if/TCLIService.thrift
index 4d7e89e..17df32e 100644
--- a/src/service/if/TCLIService.thrift
+++ b/src/service/if/TCLIService.thrift
@@ -961,6 +961,22 @@ struct TFetchResultsResp {
   3: optional TRowSet results
 }
 
+// GetLog()
+//
+// Fetch operation log from the server corresponding to
+// a particular OperationHandle.
+struct TGetLogReq {
+  // Operation whose log is requested
+  1: required TOperationHandle operationHandle
+}
+
+struct TGetLogResp {
+  1: required TStatus status
+
+  2: required string log
+
+}
+
 service TCLIService {
 
   TOpenSessionResp OpenSession(1:TOpenSessionReq req);
@@ -994,4 +1010,6 @@ service TCLIService {
   TGetResultSetMetadataResp GetResultSetMetadata(1:TGetResultSetMetadataReq req);
   
   TFetchResultsResp FetchResults(1:TFetchResultsReq req);
+  
+  TGetLogResp GetLog(1:TGetLogReq req);
 }
diff --git a/src/service/src/gen/thrift/gen-cpp/TCLIService.cpp b/src/service/src/gen/thrift/gen-cpp/TCLIService.cpp
index f8afc09..645c9a6 100644
--- a/src/service/src/gen/thrift/gen-cpp/TCLIService.cpp
+++ b/src/service/src/gen/thrift/gen-cpp/TCLIService.cpp
@@ -2600,6 +2600,168 @@ uint32_t TCLIService_FetchResults_presult::read(::apache::thrift::protocol::TPro
   return xfer;
 }
 
+uint32_t TCLIService_GetLog_args::read(::apache::thrift::protocol::TProtocol* iprot) {
+
+  uint32_t xfer = 0;
+  std::string fname;
+  ::apache::thrift::protocol::TType ftype;
+  int16_t fid;
+
+  xfer += iprot->readStructBegin(fname);
+
+  using ::apache::thrift::protocol::TProtocolException;
+
+
+  while (true)
+  {
+    xfer += iprot->readFieldBegin(fname, ftype, fid);
+    if (ftype == ::apache::thrift::protocol::T_STOP) {
+      break;
+    }
+    switch (fid)
+    {
+      case 1:
+        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
+          xfer += this->req.read(iprot);
+          this->__isset.req = true;
+        } else {
+          xfer += iprot->skip(ftype);
+        }
+        break;
+      default:
+        xfer += iprot->skip(ftype);
+        break;
+    }
+    xfer += iprot->readFieldEnd();
+  }
+
+  xfer += iprot->readStructEnd();
+
+  return xfer;
+}
+
+uint32_t TCLIService_GetLog_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
+  uint32_t xfer = 0;
+  xfer += oprot->writeStructBegin("TCLIService_GetLog_args");
+
+  xfer += oprot->writeFieldBegin("req", ::apache::thrift::protocol::T_STRUCT, 1);
+  xfer += this->req.write(oprot);
+  xfer += oprot->writeFieldEnd();
+
+  xfer += oprot->writeFieldStop();
+  xfer += oprot->writeStructEnd();
+  return xfer;
+}
+
+uint32_t TCLIService_GetLog_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
+  uint32_t xfer = 0;
+  xfer += oprot->writeStructBegin("TCLIService_GetLog_pargs");
+
+  xfer += oprot->writeFieldBegin("req", ::apache::thrift::protocol::T_STRUCT, 1);
+  xfer += (*(this->req)).write(oprot);
+  xfer += oprot->writeFieldEnd();
+
+  xfer += oprot->writeFieldStop();
+  xfer += oprot->writeStructEnd();
+  return xfer;
+}
+
+uint32_t TCLIService_GetLog_result::read(::apache::thrift::protocol::TProtocol* iprot) {
+
+  uint32_t xfer = 0;
+  std::string fname;
+  ::apache::thrift::protocol::TType ftype;
+  int16_t fid;
+
+  xfer += iprot->readStructBegin(fname);
+
+  using ::apache::thrift::protocol::TProtocolException;
+
+
+  while (true)
+  {
+    xfer += iprot->readFieldBegin(fname, ftype, fid);
+    if (ftype == ::apache::thrift::protocol::T_STOP) {
+      break;
+    }
+    switch (fid)
+    {
+      case 0:
+        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
+          xfer += this->success.read(iprot);
+          this->__isset.success = true;
+        } else {
+          xfer += iprot->skip(ftype);
+        }
+        break;
+      default:
+        xfer += iprot->skip(ftype);
+        break;
+    }
+    xfer += iprot->readFieldEnd();
+  }
+
+  xfer += iprot->readStructEnd();
+
+  return xfer;
+}
+
+uint32_t TCLIService_GetLog_result::write(::apache::thrift::protocol::TProtocol* oprot) const {
+
+  uint32_t xfer = 0;
+
+  xfer += oprot->writeStructBegin("TCLIService_GetLog_result");
+
+  if (this->__isset.success) {
+    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
+    xfer += this->success.write(oprot);
+    xfer += oprot->writeFieldEnd();
+  }
+  xfer += oprot->writeFieldStop();
+  xfer += oprot->writeStructEnd();
+  return xfer;
+}
+
+uint32_t TCLIService_GetLog_presult::read(::apache::thrift::protocol::TProtocol* iprot) {
+
+  uint32_t xfer = 0;
+  std::string fname;
+  ::apache::thrift::protocol::TType ftype;
+  int16_t fid;
+
+  xfer += iprot->readStructBegin(fname);
+
+  using ::apache::thrift::protocol::TProtocolException;
+
+
+  while (true)
+  {
+    xfer += iprot->readFieldBegin(fname, ftype, fid);
+    if (ftype == ::apache::thrift::protocol::T_STOP) {
+      break;
+    }
+    switch (fid)
+    {
+      case 0:
+        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
+          xfer += (*(this->success)).read(iprot);
+          this->__isset.success = true;
+        } else {
+          xfer += iprot->skip(ftype);
+        }
+        break;
+      default:
+        xfer += iprot->skip(ftype);
+        break;
+    }
+    xfer += iprot->readFieldEnd();
+  }
+
+  xfer += iprot->readStructEnd();
+
+  return xfer;
+}
+
 void TCLIServiceClient::OpenSession(TOpenSessionResp& _return, const TOpenSessionReq& req)
 {
   send_OpenSession(req);
@@ -3528,6 +3690,64 @@ void TCLIServiceClient::recv_FetchResults(TFetchResultsResp& _return)
   throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "FetchResults failed: unknown result");
 }
 
+void TCLIServiceClient::GetLog(TGetLogResp& _return, const TGetLogReq& req)
+{
+  send_GetLog(req);
+  recv_GetLog(_return);
+}
+
+void TCLIServiceClient::send_GetLog(const TGetLogReq& req)
+{
+  int32_t cseqid = 0;
+  oprot_->writeMessageBegin("GetLog", ::apache::thrift::protocol::T_CALL, cseqid);
+
+  TCLIService_GetLog_pargs args;
+  args.req = &req;
+  args.write(oprot_);
+
+  oprot_->writeMessageEnd();
+  oprot_->getTransport()->writeEnd();
+  oprot_->getTransport()->flush();
+}
+
+void TCLIServiceClient::recv_GetLog(TGetLogResp& _return)
+{
+
+  int32_t rseqid = 0;
+  std::string fname;
+  ::apache::thrift::protocol::TMessageType mtype;
+
+  iprot_->readMessageBegin(fname, mtype, rseqid);
+  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
+    ::apache::thrift::TApplicationException x;
+    x.read(iprot_);
+    iprot_->readMessageEnd();
+    iprot_->getTransport()->readEnd();
+    throw x;
+  }
+  if (mtype != ::apache::thrift::protocol::T_REPLY) {
+    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
+    iprot_->readMessageEnd();
+    iprot_->getTransport()->readEnd();
+  }
+  if (fname.compare("GetLog") != 0) {
+    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
+    iprot_->readMessageEnd();
+    iprot_->getTransport()->readEnd();
+  }
+  TCLIService_GetLog_presult result;
+  result.success = &_return;
+  result.read(iprot_);
+  iprot_->readMessageEnd();
+  iprot_->getTransport()->readEnd();
+
+  if (result.__isset.success) {
+    // _return pointer has now been filled
+    return;
+  }
+  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetLog failed: unknown result");
+}
+
 bool TCLIServiceProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
   ProcessMap::iterator pfn;
   pfn = processMap_.find(fname);
@@ -4411,6 +4631,60 @@ void TCLIServiceProcessor::process_FetchResults(int32_t seqid, ::apache::thrift:
   }
 }
 
+void TCLIServiceProcessor::process_GetLog(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
+{
+  void* ctx = NULL;
+  if (this->eventHandler_.get() != NULL) {
+    ctx = this->eventHandler_->getContext("TCLIService.GetLog", callContext);
+  }
+  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TCLIService.GetLog");
+
+  if (this->eventHandler_.get() != NULL) {
+    this->eventHandler_->preRead(ctx, "TCLIService.GetLog");
+  }
+
+  TCLIService_GetLog_args args;
+  args.read(iprot);
+  iprot->readMessageEnd();
+  uint32_t bytes = iprot->getTransport()->readEnd();
+
+  if (this->eventHandler_.get() != NULL) {
+    this->eventHandler_->postRead(ctx, "TCLIService.GetLog", bytes);
+  }
+
+  TCLIService_GetLog_result result;
+  try {
+    iface_->GetLog(result.success, args.req);
+    result.__isset.success = true;
+  } catch (const std::exception& e) {
+    if (this->eventHandler_.get() != NULL) {
+      this->eventHandler_->handlerError(ctx, "TCLIService.GetLog");
+    }
+
+    ::apache::thrift::TApplicationException x(e.what());
+    oprot->writeMessageBegin("GetLog", ::apache::thrift::protocol::T_EXCEPTION, seqid);
+    x.write(oprot);
+    oprot->writeMessageEnd();
+    oprot->getTransport()->writeEnd();
+    oprot->getTransport()->flush();
+    return;
+  }
+
+  if (this->eventHandler_.get() != NULL) {
+    this->eventHandler_->preWrite(ctx, "TCLIService.GetLog");
+  }
+
+  oprot->writeMessageBegin("GetLog", ::apache::thrift::protocol::T_REPLY, seqid);
+  result.write(oprot);
+  oprot->writeMessageEnd();
+  bytes = oprot->getTransport()->writeEnd();
+  oprot->getTransport()->flush();
+
+  if (this->eventHandler_.get() != NULL) {
+    this->eventHandler_->postWrite(ctx, "TCLIService.GetLog", bytes);
+  }
+}
+
 ::boost::shared_ptr< ::apache::thrift::TProcessor > TCLIServiceProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
   ::apache::thrift::ReleaseHandler< TCLIServiceIfFactory > cleanup(handlerFactory_);
   ::boost::shared_ptr< TCLIServiceIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
diff --git a/src/service/src/gen/thrift/gen-cpp/TCLIService.h b/src/service/src/gen/thrift/gen-cpp/TCLIService.h
index 055cfa6..e48b443 100644
--- a/src/service/src/gen/thrift/gen-cpp/TCLIService.h
+++ b/src/service/src/gen/thrift/gen-cpp/TCLIService.h
@@ -31,6 +31,7 @@ class TCLIServiceIf {
   virtual void CloseOperation(TCloseOperationResp& _return, const TCloseOperationReq& req) = 0;
   virtual void GetResultSetMetadata(TGetResultSetMetadataResp& _return, const TGetResultSetMetadataReq& req) = 0;
   virtual void FetchResults(TFetchResultsResp& _return, const TFetchResultsReq& req) = 0;
+  virtual void GetLog(TGetLogResp& _return, const TGetLogReq& req) = 0;
 };
 
 class TCLIServiceIfFactory {
@@ -108,6 +109,9 @@ class TCLIServiceNull : virtual public TCLIServiceIf {
   void FetchResults(TFetchResultsResp& /* _return */, const TFetchResultsReq& /* req */) {
     return;
   }
+  void GetLog(TGetLogResp& /* _return */, const TGetLogReq& /* req */) {
+    return;
+  }
 };
 
 typedef struct _TCLIService_OpenSession_args__isset {
@@ -1838,6 +1842,114 @@ class TCLIService_FetchResults_presult {
 
 };
 
+typedef struct _TCLIService_GetLog_args__isset {
+  _TCLIService_GetLog_args__isset() : req(false) {}
+  bool req;
+} _TCLIService_GetLog_args__isset;
+
+class TCLIService_GetLog_args {
+ public:
+
+  TCLIService_GetLog_args() {
+  }
+
+  virtual ~TCLIService_GetLog_args() throw() {}
+
+  TGetLogReq req;
+
+  _TCLIService_GetLog_args__isset __isset;
+
+  void __set_req(const TGetLogReq& val) {
+    req = val;
+  }
+
+  bool operator == (const TCLIService_GetLog_args & rhs) const
+  {
+    if (!(req == rhs.req))
+      return false;
+    return true;
+  }
+  bool operator != (const TCLIService_GetLog_args &rhs) const {
+    return !(*this == rhs);
+  }
+
+  bool operator < (const TCLIService_GetLog_args & ) const;
+
+  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
+  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;
+
+};
+
+
+class TCLIService_GetLog_pargs {
+ public:
+
+
+  virtual ~TCLIService_GetLog_pargs() throw() {}
+
+  const TGetLogReq* req;
+
+  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;
+
+};
+
+typedef struct _TCLIService_GetLog_result__isset {
+  _TCLIService_GetLog_result__isset() : success(false) {}
+  bool success;
+} _TCLIService_GetLog_result__isset;
+
+class TCLIService_GetLog_result {
+ public:
+
+  TCLIService_GetLog_result() {
+  }
+
+  virtual ~TCLIService_GetLog_result() throw() {}
+
+  TGetLogResp success;
+
+  _TCLIService_GetLog_result__isset __isset;
+
+  void __set_success(const TGetLogResp& val) {
+    success = val;
+  }
+
+  bool operator == (const TCLIService_GetLog_result & rhs) const
+  {
+    if (!(success == rhs.success))
+      return false;
+    return true;
+  }
+  bool operator != (const TCLIService_GetLog_result &rhs) const {
+    return !(*this == rhs);
+  }
+
+  bool operator < (const TCLIService_GetLog_result & ) const;
+
+  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
+  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;
+
+};
+
+typedef struct _TCLIService_GetLog_presult__isset {
+  _TCLIService_GetLog_presult__isset() : success(false) {}
+  bool success;
+} _TCLIService_GetLog_presult__isset;
+
+class TCLIService_GetLog_presult {
+ public:
+
+
+  virtual ~TCLIService_GetLog_presult() throw() {}
+
+  TGetLogResp* success;
+
+  _TCLIService_GetLog_presult__isset __isset;
+
+  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
+
+};
+
 class TCLIServiceClient : virtual public TCLIServiceIf {
  public:
   TCLIServiceClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
@@ -1906,6 +2018,9 @@ class TCLIServiceClient : virtual public TCLIServiceIf {
   void FetchResults(TFetchResultsResp& _return, const TFetchResultsReq& req);
   void send_FetchResults(const TFetchResultsReq& req);
   void recv_FetchResults(TFetchResultsResp& _return);
+  void GetLog(TGetLogResp& _return, const TGetLogReq& req);
+  void send_GetLog(const TGetLogReq& req);
+  void recv_GetLog(TGetLogResp& _return);
  protected:
   boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
   boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
@@ -1937,6 +2052,7 @@ class TCLIServiceProcessor : public ::apache::thrift::TDispatchProcessor {
   void process_CloseOperation(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
   void process_GetResultSetMetadata(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
   void process_FetchResults(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
+  void process_GetLog(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  public:
   TCLIServiceProcessor(boost::shared_ptr<TCLIServiceIf> iface) :
     iface_(iface) {
@@ -1956,6 +2072,7 @@ class TCLIServiceProcessor : public ::apache::thrift::TDispatchProcessor {
     processMap_["CloseOperation"] = &TCLIServiceProcessor::process_CloseOperation;
     processMap_["GetResultSetMetadata"] = &TCLIServiceProcessor::process_GetResultSetMetadata;
     processMap_["FetchResults"] = &TCLIServiceProcessor::process_FetchResults;
+    processMap_["GetLog"] = &TCLIServiceProcessor::process_GetLog;
   }
 
   virtual ~TCLIServiceProcessor() {}
@@ -2144,6 +2261,16 @@ class TCLIServiceMultiface : virtual public TCLIServiceIf {
     return;
   }
 
+  void GetLog(TGetLogResp& _return, const TGetLogReq& req) {
+    size_t sz = ifaces_.size();
+    size_t i = 0;
+    for (; i < (sz - 1); ++i) {
+      ifaces_[i]->GetLog(_return, req);
+    }
+    ifaces_[i]->GetLog(_return, req);
+    return;
+  }
+
 };
 
 }}}}} // namespace
diff --git a/src/service/src/gen/thrift/gen-cpp/TCLIService_server.skeleton.cpp b/src/service/src/gen/thrift/gen-cpp/TCLIService_server.skeleton.cpp
index d1d31cb..df99f93 100644
--- a/src/service/src/gen/thrift/gen-cpp/TCLIService_server.skeleton.cpp
+++ b/src/service/src/gen/thrift/gen-cpp/TCLIService_server.skeleton.cpp
@@ -102,6 +102,11 @@ class TCLIServiceHandler : virtual public TCLIServiceIf {
     printf("FetchResults\n");
   }
 
+  void GetLog(TGetLogResp& _return, const TGetLogReq& req) {
+    // Your implementation goes here
+    printf("GetLog\n");
+  }
+
 };
 
 int main(int argc, char **argv) {
diff --git a/src/service/src/gen/thrift/gen-cpp/TCLIService_types.cpp b/src/service/src/gen/thrift/gen-cpp/TCLIService_types.cpp
index ef47f5c..b63e76d 100644
--- a/src/service/src/gen/thrift/gen-cpp/TCLIService_types.cpp
+++ b/src/service/src/gen/thrift/gen-cpp/TCLIService_types.cpp
@@ -5397,4 +5397,148 @@ void swap(TFetchResultsResp &a, TFetchResultsResp &b) {
   swap(a.__isset, b.__isset);
 }
 
+const char* TGetLogReq::ascii_fingerprint = "414FA38522AE6B9CEC1438B56CA1DE5A";
+const uint8_t TGetLogReq::binary_fingerprint[16] = {0x41,0x4F,0xA3,0x85,0x22,0xAE,0x6B,0x9C,0xEC,0x14,0x38,0xB5,0x6C,0xA1,0xDE,0x5A};
+
+uint32_t TGetLogReq::read(::apache::thrift::protocol::TProtocol* iprot) {
+
+  uint32_t xfer = 0;
+  std::string fname;
+  ::apache::thrift::protocol::TType ftype;
+  int16_t fid;
+
+  xfer += iprot->readStructBegin(fname);
+
+  using ::apache::thrift::protocol::TProtocolException;
+
+  bool isset_operationHandle = false;
+
+  while (true)
+  {
+    xfer += iprot->readFieldBegin(fname, ftype, fid);
+    if (ftype == ::apache::thrift::protocol::T_STOP) {
+      break;
+    }
+    switch (fid)
+    {
+      case 1:
+        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
+          xfer += this->operationHandle.read(iprot);
+          isset_operationHandle = true;
+        } else {
+          xfer += iprot->skip(ftype);
+        }
+        break;
+      default:
+        xfer += iprot->skip(ftype);
+        break;
+    }
+    xfer += iprot->readFieldEnd();
+  }
+
+  xfer += iprot->readStructEnd();
+
+  if (!isset_operationHandle)
+    throw TProtocolException(TProtocolException::INVALID_DATA);
+  return xfer;
+}
+
+uint32_t TGetLogReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
+  uint32_t xfer = 0;
+  xfer += oprot->writeStructBegin("TGetLogReq");
+
+  xfer += oprot->writeFieldBegin("operationHandle", ::apache::thrift::protocol::T_STRUCT, 1);
+  xfer += this->operationHandle.write(oprot);
+  xfer += oprot->writeFieldEnd();
+
+  xfer += oprot->writeFieldStop();
+  xfer += oprot->writeStructEnd();
+  return xfer;
+}
+
+void swap(TGetLogReq &a, TGetLogReq &b) {
+  using ::std::swap;
+  swap(a.operationHandle, b.operationHandle);
+}
+
+const char* TGetLogResp::ascii_fingerprint = "08A7F68AF7400F358E5CF08185165CB7";
+const uint8_t TGetLogResp::binary_fingerprint[16] = {0x08,0xA7,0xF6,0x8A,0xF7,0x40,0x0F,0x35,0x8E,0x5C,0xF0,0x81,0x85,0x16,0x5C,0xB7};
+
+uint32_t TGetLogResp::read(::apache::thrift::protocol::TProtocol* iprot) {
+
+  uint32_t xfer = 0;
+  std::string fname;
+  ::apache::thrift::protocol::TType ftype;
+  int16_t fid;
+
+  xfer += iprot->readStructBegin(fname);
+
+  using ::apache::thrift::protocol::TProtocolException;
+
+  bool isset_status = false;
+  bool isset_log = false;
+
+  while (true)
+  {
+    xfer += iprot->readFieldBegin(fname, ftype, fid);
+    if (ftype == ::apache::thrift::protocol::T_STOP) {
+      break;
+    }
+    switch (fid)
+    {
+      case 1:
+        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
+          xfer += this->status.read(iprot);
+          isset_status = true;
+        } else {
+          xfer += iprot->skip(ftype);
+        }
+        break;
+      case 2:
+        if (ftype == ::apache::thrift::protocol::T_STRING) {
+          xfer += iprot->readString(this->log);
+          isset_log = true;
+        } else {
+          xfer += iprot->skip(ftype);
+        }
+        break;
+      default:
+        xfer += iprot->skip(ftype);
+        break;
+    }
+    xfer += iprot->readFieldEnd();
+  }
+
+  xfer += iprot->readStructEnd();
+
+  if (!isset_status)
+    throw TProtocolException(TProtocolException::INVALID_DATA);
+  if (!isset_log)
+    throw TProtocolException(TProtocolException::INVALID_DATA);
+  return xfer;
+}
+
+uint32_t TGetLogResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
+  uint32_t xfer = 0;
+  xfer += oprot->writeStructBegin("TGetLogResp");
+
+  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
+  xfer += this->status.write(oprot);
+  xfer += oprot->writeFieldEnd();
+
+  xfer += oprot->writeFieldBegin("log", ::apache::thrift::protocol::T_STRING, 2);
+  xfer += oprot->writeString(this->log);
+  xfer += oprot->writeFieldEnd();
+
+  xfer += oprot->writeFieldStop();
+  xfer += oprot->writeStructEnd();
+  return xfer;
+}
+
+void swap(TGetLogResp &a, TGetLogResp &b) {
+  using ::std::swap;
+  swap(a.status, b.status);
+  swap(a.log, b.log);
+}
+
 }}}}} // namespace
diff --git a/src/service/src/gen/thrift/gen-cpp/TCLIService_types.h b/src/service/src/gen/thrift/gen-cpp/TCLIService_types.h
index f1d846b..5e820bf 100644
--- a/src/service/src/gen/thrift/gen-cpp/TCLIService_types.h
+++ b/src/service/src/gen/thrift/gen-cpp/TCLIService_types.h
@@ -3194,6 +3194,87 @@ class TFetchResultsResp {
 
 void swap(TFetchResultsResp &a, TFetchResultsResp &b);
 
+
+class TGetLogReq {
+ public:
+
+  static const char* ascii_fingerprint; // = "414FA38522AE6B9CEC1438B56CA1DE5A";
+  static const uint8_t binary_fingerprint[16]; // = {0x41,0x4F,0xA3,0x85,0x22,0xAE,0x6B,0x9C,0xEC,0x14,0x38,0xB5,0x6C,0xA1,0xDE,0x5A};
+
+  TGetLogReq() {
+  }
+
+  virtual ~TGetLogReq() throw() {}
+
+  TOperationHandle operationHandle;
+
+  void __set_operationHandle(const TOperationHandle& val) {
+    operationHandle = val;
+  }
+
+  bool operator == (const TGetLogReq & rhs) const
+  {
+    if (!(operationHandle == rhs.operationHandle))
+      return false;
+    return true;
+  }
+  bool operator != (const TGetLogReq &rhs) const {
+    return !(*this == rhs);
+  }
+
+  bool operator < (const TGetLogReq & ) const;
+
+  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
+  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;
+
+};
+
+void swap(TGetLogReq &a, TGetLogReq &b);
+
+
+class TGetLogResp {
+ public:
+
+  static const char* ascii_fingerprint; // = "08A7F68AF7400F358E5CF08185165CB7";
+  static const uint8_t binary_fingerprint[16]; // = {0x08,0xA7,0xF6,0x8A,0xF7,0x40,0x0F,0x35,0x8E,0x5C,0xF0,0x81,0x85,0x16,0x5C,0xB7};
+
+  TGetLogResp() : log() {
+  }
+
+  virtual ~TGetLogResp() throw() {}
+
+  TStatus status;
+  std::string log;
+
+  void __set_status(const TStatus& val) {
+    status = val;
+  }
+
+  void __set_log(const std::string& val) {
+    log = val;
+  }
+
+  bool operator == (const TGetLogResp & rhs) const
+  {
+    if (!(status == rhs.status))
+      return false;
+    if (!(log == rhs.log))
+      return false;
+    return true;
+  }
+  bool operator != (const TGetLogResp &rhs) const {
+    return !(*this == rhs);
+  }
+
+  bool operator < (const TGetLogResp & ) const;
+
+  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
+  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;
+
+};
+
+void swap(TGetLogResp &a, TGetLogResp &b);
+
 }}}}} // namespace
 
 #endif
diff --git a/src/service/src/gen/thrift/gen-javabean/org/apache/hive/service/cli/thrift/TCLIService.java b/src/service/src/gen/thrift/gen-javabean/org/apache/hive/service/cli/thrift/TCLIService.java
index b296c66..3e628dd 100644
--- a/src/service/src/gen/thrift/gen-javabean/org/apache/hive/service/cli/thrift/TCLIService.java
+++ b/src/service/src/gen/thrift/gen-javabean/org/apache/hive/service/cli/thrift/TCLIService.java
@@ -67,6 +67,8 @@ public class TCLIService {
 
     public TFetchResultsResp FetchResults(TFetchResultsReq req) throws org.apache.thrift.TException;
 
+    public TGetLogResp GetLog(TGetLogReq req) throws org.apache.thrift.TException;
+
   }
 
   public interface AsyncIface {
@@ -103,6 +105,8 @@ public class TCLIService {
 
     public void FetchResults(TFetchResultsReq req, org.apache.thrift.async.AsyncMethodCallback<AsyncClient.FetchResults_call> resultHandler) throws org.apache.thrift.TException;
 
+    public void GetLog(TGetLogReq req, org.apache.thrift.async.AsyncMethodCallback<AsyncClient.GetLog_call> resultHandler) throws org.apache.thrift.TException;
+
   }
 
   public static class Client extends org.apache.thrift.TServiceClient implements Iface {
@@ -493,6 +497,29 @@ public class TCLIService {
       throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "FetchResults failed: unknown result");
     }
 
+    public TGetLogResp GetLog(TGetLogReq req) throws org.apache.thrift.TException
+    {
+      send_GetLog(req);
+      return recv_GetLog();
+    }
+
+    public void send_GetLog(TGetLogReq req) throws org.apache.thrift.TException
+    {
+      GetLog_args args = new GetLog_args();
+      args.setReq(req);
+      sendBase("GetLog", args);
+    }
+
+    public TGetLogResp recv_GetLog() throws org.apache.thrift.TException
+    {
+      GetLog_result result = new GetLog_result();
+      receiveBase(result, "GetLog");
+      if (result.isSetSuccess()) {
+        return result.success;
+      }
+      throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "GetLog failed: unknown result");
+    }
+
   }
   public static class AsyncClient extends org.apache.thrift.async.TAsyncClient implements AsyncIface {
     public static class Factory implements org.apache.thrift.async.TAsyncClientFactory<AsyncClient> {
@@ -1023,6 +1050,38 @@ public class TCLIService {
       }
     }
 
+    public void GetLog(TGetLogReq req, org.apache.thrift.async.AsyncMethodCallback<GetLog_call> resultHandler) throws org.apache.thrift.TException {
+      checkReady();
+      GetLog_call method_call = new GetLog_call(req, resultHandler, this, ___protocolFactory, ___transport);
+      this.___currentMethod = method_call;
+      ___manager.call(method_call);
+    }
+
+    public static class GetLog_call extends org.apache.thrift.async.TAsyncMethodCall {
+      private TGetLogReq req;
+      public GetLog_call(TGetLogReq req, org.apache.thrift.async.AsyncMethodCallback<GetLog_call> resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
+        super(client, protocolFactory, transport, resultHandler, false);
+        this.req = req;
+      }
+
+      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
+        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("GetLog", org.apache.thrift.protocol.TMessageType.CALL, 0));
+        GetLog_args args = new GetLog_args();
+        args.setReq(req);
+        args.write(prot);
+        prot.writeMessageEnd();
+      }
+
+      public TGetLogResp getResult() throws org.apache.thrift.TException {
+        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
+          throw new IllegalStateException("Method call not finished!");
+        }
+        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
+        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
+        return (new Client(prot)).recv_GetLog();
+      }
+    }
+
   }
 
   public static class Processor<I extends Iface> extends org.apache.thrift.TBaseProcessor<I> implements org.apache.thrift.TProcessor {
@@ -1052,6 +1111,7 @@ public class TCLIService {
       processMap.put("CloseOperation", new CloseOperation());
       processMap.put("GetResultSetMetadata", new GetResultSetMetadata());
       processMap.put("FetchResults", new FetchResults());
+      processMap.put("GetLog", new GetLog());
       return processMap;
     }
 
@@ -1375,6 +1435,26 @@ public class TCLIService {
       }
     }
 
+    public static class GetLog<I extends Iface> extends org.apache.thrift.ProcessFunction<I, GetLog_args> {
+      public GetLog() {
+        super("GetLog");
+      }
+
+      public GetLog_args getEmptyArgsInstance() {
+        return new GetLog_args();
+      }
+
+      protected boolean isOneway() {
+        return false;
+      }
+
+      public GetLog_result getResult(I iface, GetLog_args args) throws org.apache.thrift.TException {
+        GetLog_result result = new GetLog_result();
+        result.success = iface.GetLog(args.req);
+        return result;
+      }
+    }
+
   }
 
   public static class OpenSession_args implements org.apache.thrift.TBase<OpenSession_args, OpenSession_args._Fields>, java.io.Serializable, Cloneable   {
@@ -12993,4 +13073,730 @@ public class TCLIService {
 
   }
 
+  public static class GetLog_args implements org.apache.thrift.TBase<GetLog_args, GetLog_args._Fields>, java.io.Serializable, Cloneable   {
+    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("GetLog_args");
+
+    private static final org.apache.thrift.protocol.TField REQ_FIELD_DESC = new org.apache.thrift.protocol.TField("req", org.apache.thrift.protocol.TType.STRUCT, (short)1);
+
+    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
+    static {
+      schemes.put(StandardScheme.class, new GetLog_argsStandardSchemeFactory());
+      schemes.put(TupleScheme.class, new GetLog_argsTupleSchemeFactory());
+    }
+
+    private TGetLogReq req; // required
+
+    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
+    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
+      REQ((short)1, "req");
+
+      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
+
+      static {
+        for (_Fields field : EnumSet.allOf(_Fields.class)) {
+          byName.put(field.getFieldName(), field);
+        }
+      }
+
+      /**
+       * Find the _Fields constant that matches fieldId, or null if its not found.
+       */
+      public static _Fields findByThriftId(int fieldId) {
+        switch(fieldId) {
+          case 1: // REQ
+            return REQ;
+          default:
+            return null;
+        }
+      }
+
+      /**
+       * Find the _Fields constant that matches fieldId, throwing an exception
+       * if it is not found.
+       */
+      public static _Fields findByThriftIdOrThrow(int fieldId) {
+        _Fields fields = findByThriftId(fieldId);
+        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
+        return fields;
+      }
+
+      /**
+       * Find the _Fields constant that matches name, or null if its not found.
+       */
+      public static _Fields findByName(String name) {
+        return byName.get(name);
+      }
+
+      private final short _thriftId;
+      private final String _fieldName;
+
+      _Fields(short thriftId, String fieldName) {
+        _thriftId = thriftId;
+        _fieldName = fieldName;
+      }
+
+      public short getThriftFieldId() {
+        return _thriftId;
+      }
+
+      public String getFieldName() {
+        return _fieldName;
+      }
+    }
+
+    // isset id assignments
+    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
+    static {
+      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
+      tmpMap.put(_Fields.REQ, new org.apache.thrift.meta_data.FieldMetaData("req", org.apache.thrift.TFieldRequirementType.DEFAULT, 
+          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, TGetLogReq.class)));
+      metaDataMap = Collections.unmodifiableMap(tmpMap);
+      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(GetLog_args.class, metaDataMap);
+    }
+
+    public GetLog_args() {
+    }
+
+    public GetLog_args(
+      TGetLogReq req)
+    {
+      this();
+      this.req = req;
+    }
+
+    /**
+     * Performs a deep copy on <i>other</i>.
+     */
+    public GetLog_args(GetLog_args other) {
+      if (other.isSetReq()) {
+        this.req = new TGetLogReq(other.req);
+      }
+    }
+
+    public GetLog_args deepCopy() {
+      return new GetLog_args(this);
+    }
+
+    @Override
+    public void clear() {
+      this.req = null;
+    }
+
+    public TGetLogReq getReq() {
+      return this.req;
+    }
+
+    public void setReq(TGetLogReq req) {
+      this.req = req;
+    }
+
+    public void unsetReq() {
+      this.req = null;
+    }
+
+    /** Returns true if field req is set (has been assigned a value) and false otherwise */
+    public boolean isSetReq() {
+      return this.req != null;
+    }
+
+    public void setReqIsSet(boolean value) {
+      if (!value) {
+        this.req = null;
+      }
+    }
+
+    public void setFieldValue(_Fields field, Object value) {
+      switch (field) {
+      case REQ:
+        if (value == null) {
+          unsetReq();
+        } else {
+          setReq((TGetLogReq)value);
+        }
+        break;
+
+      }
+    }
+
+    public Object getFieldValue(_Fields field) {
+      switch (field) {
+      case REQ:
+        return getReq();
+
+      }
+      throw new IllegalStateException();
+    }
+
+    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
+    public boolean isSet(_Fields field) {
+      if (field == null) {
+        throw new IllegalArgumentException();
+      }
+
+      switch (field) {
+      case REQ:
+        return isSetReq();
+      }
+      throw new IllegalStateException();
+    }
+
+    @Override
+    public boolean equals(Object that) {
+      if (that == null)
+        return false;
+      if (that instanceof GetLog_args)
+        return this.equals((GetLog_args)that);
+      return false;
+    }
+
+    public boolean equals(GetLog_args that) {
+      if (that == null)
+        return false;
+
+      boolean this_present_req = true && this.isSetReq();
+      boolean that_present_req = true && that.isSetReq();
+      if (this_present_req || that_present_req) {
+        if (!(this_present_req && that_present_req))
+          return false;
+        if (!this.req.equals(that.req))
+          return false;
+      }
+
+      return true;
+    }
+
+    @Override
+    public int hashCode() {
+      HashCodeBuilder builder = new HashCodeBuilder();
+
+      boolean present_req = true && (isSetReq());
+      builder.append(present_req);
+      if (present_req)
+        builder.append(req);
+
+      return builder.toHashCode();
+    }
+
+    public int compareTo(GetLog_args other) {
+      if (!getClass().equals(other.getClass())) {
+        return getClass().getName().compareTo(other.getClass().getName());
+      }
+
+      int lastComparison = 0;
+      GetLog_args typedOther = (GetLog_args)other;
+
+      lastComparison = Boolean.valueOf(isSetReq()).compareTo(typedOther.isSetReq());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      if (isSetReq()) {
+        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.req, typedOther.req);
+        if (lastComparison != 0) {
+          return lastComparison;
+        }
+      }
+      return 0;
+    }
+
+    public _Fields fieldForId(int fieldId) {
+      return _Fields.findByThriftId(fieldId);
+    }
+
+    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
+      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
+    }
+
+    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
+      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
+    }
+
+    @Override
+    public String toString() {
+      StringBuilder sb = new StringBuilder("GetLog_args(");
+      boolean first = true;
+
+      sb.append("req:");
+      if (this.req == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.req);
+      }
+      first = false;
+      sb.append(")");
+      return sb.toString();
+    }
+
+    public void validate() throws org.apache.thrift.TException {
+      // check for required fields
+      // check for sub-struct validity
+      if (req != null) {
+        req.validate();
+      }
+    }
+
+    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
+      try {
+        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
+      } catch (org.apache.thrift.TException te) {
+        throw new java.io.IOException(te);
+      }
+    }
+
+    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
+      try {
+        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
+      } catch (org.apache.thrift.TException te) {
+        throw new java.io.IOException(te);
+      }
+    }
+
+    private static class GetLog_argsStandardSchemeFactory implements SchemeFactory {
+      public GetLog_argsStandardScheme getScheme() {
+        return new GetLog_argsStandardScheme();
+      }
+    }
+
+    private static class GetLog_argsStandardScheme extends StandardScheme<GetLog_args> {
+
+      public void read(org.apache.thrift.protocol.TProtocol iprot, GetLog_args struct) throws org.apache.thrift.TException {
+        org.apache.thrift.protocol.TField schemeField;
+        iprot.readStructBegin();
+        while (true)
+        {
+          schemeField = iprot.readFieldBegin();
+          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
+            break;
+          }
+          switch (schemeField.id) {
+            case 1: // REQ
+              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
+                struct.req = new TGetLogReq();
+                struct.req.read(iprot);
+                struct.setReqIsSet(true);
+              } else { 
+                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
+              }
+              break;
+            default:
+              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
+          }
+          iprot.readFieldEnd();
+        }
+        iprot.readStructEnd();
+        struct.validate();
+      }
+
+      public void write(org.apache.thrift.protocol.TProtocol oprot, GetLog_args struct) throws org.apache.thrift.TException {
+        struct.validate();
+
+        oprot.writeStructBegin(STRUCT_DESC);
+        if (struct.req != null) {
+          oprot.writeFieldBegin(REQ_FIELD_DESC);
+          struct.req.write(oprot);
+          oprot.writeFieldEnd();
+        }
+        oprot.writeFieldStop();
+        oprot.writeStructEnd();
+      }
+
+    }
+
+    private static class GetLog_argsTupleSchemeFactory implements SchemeFactory {
+      public GetLog_argsTupleScheme getScheme() {
+        return new GetLog_argsTupleScheme();
+      }
+    }
+
+    private static class GetLog_argsTupleScheme extends TupleScheme<GetLog_args> {
+
+      @Override
+      public void write(org.apache.thrift.protocol.TProtocol prot, GetLog_args struct) throws org.apache.thrift.TException {
+        TTupleProtocol oprot = (TTupleProtocol) prot;
+        BitSet optionals = new BitSet();
+        if (struct.isSetReq()) {
+          optionals.set(0);
+        }
+        oprot.writeBitSet(optionals, 1);
+        if (struct.isSetReq()) {
+          struct.req.write(oprot);
+        }
+      }
+
+      @Override
+      public void read(org.apache.thrift.protocol.TProtocol prot, GetLog_args struct) throws org.apache.thrift.TException {
+        TTupleProtocol iprot = (TTupleProtocol) prot;
+        BitSet incoming = iprot.readBitSet(1);
+        if (incoming.get(0)) {
+          struct.req = new TGetLogReq();
+          struct.req.read(iprot);
+          struct.setReqIsSet(true);
+        }
+      }
+    }
+
+  }
+
+  public static class GetLog_result implements org.apache.thrift.TBase<GetLog_result, GetLog_result._Fields>, java.io.Serializable, Cloneable   {
+    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("GetLog_result");
+
+    private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.STRUCT, (short)0);
+
+    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
+    static {
+      schemes.put(StandardScheme.class, new GetLog_resultStandardSchemeFactory());
+      schemes.put(TupleScheme.class, new GetLog_resultTupleSchemeFactory());
+    }
+
+    private TGetLogResp success; // required
+
+    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
+    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
+      SUCCESS((short)0, "success");
+
+      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
+
+      static {
+        for (_Fields field : EnumSet.allOf(_Fields.class)) {
+          byName.put(field.getFieldName(), field);
+        }
+      }
+
+      /**
+       * Find the _Fields constant that matches fieldId, or null if its not found.
+       */
+      public static _Fields findByThriftId(int fieldId) {
+        switch(fieldId) {
+          case 0: // SUCCESS
+            return SUCCESS;
+          default:
+            return null;
+        }
+      }
+
+      /**
+       * Find the _Fields constant that matches fieldId, throwing an exception
+       * if it is not found.
+       */
+      public static _Fields findByThriftIdOrThrow(int fieldId) {
+        _Fields fields = findByThriftId(fieldId);
+        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
+        return fields;
+      }
+
+      /**
+       * Find the _Fields constant that matches name, or null if its not found.
+       */
+      public static _Fields findByName(String name) {
+        return byName.get(name);
+      }
+
+      private final short _thriftId;
+      private final String _fieldName;
+
+      _Fields(short thriftId, String fieldName) {
+        _thriftId = thriftId;
+        _fieldName = fieldName;
+      }
+
+      public short getThriftFieldId() {
+        return _thriftId;
+      }
+
+      public String getFieldName() {
+        return _fieldName;
+      }
+    }
+
+    // isset id assignments
+    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
+    static {
+      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
+      tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
+          new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, TGetLogResp.class)));
+      metaDataMap = Collections.unmodifiableMap(tmpMap);
+      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(GetLog_result.class, metaDataMap);
+    }
+
+    public GetLog_result() {
+    }
+
+    public GetLog_result(
+      TGetLogResp success)
+    {
+      this();
+      this.success = success;
+    }
+
+    /**
+     * Performs a deep copy on <i>other</i>.
+     */
+    public GetLog_result(GetLog_result other) {
+      if (other.isSetSuccess()) {
+        this.success = new TGetLogResp(other.success);
+      }
+    }
+
+    public GetLog_result deepCopy() {
+      return new GetLog_result(this);
+    }
+
+    @Override
+    public void clear() {
+      this.success = null;
+    }
+
+    public TGetLogResp getSuccess() {
+      return this.success;
+    }
+
+    public void setSuccess(TGetLogResp success) {
+      this.success = success;
+    }
+
+    public void unsetSuccess() {
+      this.success = null;
+    }
+
+    /** Returns true if field success is set (has been assigned a value) and false otherwise */
+    public boolean isSetSuccess() {
+      return this.success != null;
+    }
+
+    public void setSuccessIsSet(boolean value) {
+      if (!value) {
+        this.success = null;
+      }
+    }
+
+    public void setFieldValue(_Fields field, Object value) {
+      switch (field) {
+      case SUCCESS:
+        if (value == null) {
+          unsetSuccess();
+        } else {
+          setSuccess((TGetLogResp)value);
+        }
+        break;
+
+      }
+    }
+
+    public Object getFieldValue(_Fields field) {
+      switch (field) {
+      case SUCCESS:
+        return getSuccess();
+
+      }
+      throw new IllegalStateException();
+    }
+
+    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
+    public boolean isSet(_Fields field) {
+      if (field == null) {
+        throw new IllegalArgumentException();
+      }
+
+      switch (field) {
+      case SUCCESS:
+        return isSetSuccess();
+      }
+      throw new IllegalStateException();
+    }
+
+    @Override
+    public boolean equals(Object that) {
+      if (that == null)
+        return false;
+      if (that instanceof GetLog_result)
+        return this.equals((GetLog_result)that);
+      return false;
+    }
+
+    public boolean equals(GetLog_result that) {
+      if (that == null)
+        return false;
+
+      boolean this_present_success = true && this.isSetSuccess();
+      boolean that_present_success = true && that.isSetSuccess();
+      if (this_present_success || that_present_success) {
+        if (!(this_present_success && that_present_success))
+          return false;
+        if (!this.success.equals(that.success))
+          return false;
+      }
+
+      return true;
+    }
+
+    @Override
+    public int hashCode() {
+      HashCodeBuilder builder = new HashCodeBuilder();
+
+      boolean present_success = true && (isSetSuccess());
+      builder.append(present_success);
+      if (present_success)
+        builder.append(success);
+
+      return builder.toHashCode();
+    }
+
+    public int compareTo(GetLog_result other) {
+      if (!getClass().equals(other.getClass())) {
+        return getClass().getName().compareTo(other.getClass().getName());
+      }
+
+      int lastComparison = 0;
+      GetLog_result typedOther = (GetLog_result)other;
+
+      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      if (isSetSuccess()) {
+        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, typedOther.success);
+        if (lastComparison != 0) {
+          return lastComparison;
+        }
+      }
+      return 0;
+    }
+
+    public _Fields fieldForId(int fieldId) {
+      return _Fields.findByThriftId(fieldId);
+    }
+
+    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
+      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
+    }
+
+    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
+      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
+      }
+
+    @Override
+    public String toString() {
+      StringBuilder sb = new StringBuilder("GetLog_result(");
+      boolean first = true;
+
+      sb.append("success:");
+      if (this.success == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.success);
+      }
+      first = false;
+      sb.append(")");
+      return sb.toString();
+    }
+
+    public void validate() throws org.apache.thrift.TException {
+      // check for required fields
+      // check for sub-struct validity
+      if (success != null) {
+        success.validate();
+      }
+    }
+
+    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
+      try {
+        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
+      } catch (org.apache.thrift.TException te) {
+        throw new java.io.IOException(te);
+      }
+    }
+
+    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
+      try {
+        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
+      } catch (org.apache.thrift.TException te) {
+        throw new java.io.IOException(te);
+      }
+    }
+
+    private static class GetLog_resultStandardSchemeFactory implements SchemeFactory {
+      public GetLog_resultStandardScheme getScheme() {
+        return new GetLog_resultStandardScheme();
+      }
+    }
+
+    private static class GetLog_resultStandardScheme extends StandardScheme<GetLog_result> {
+
+      public void read(org.apache.thrift.protocol.TProtocol iprot, GetLog_result struct) throws org.apache.thrift.TException {
+        org.apache.thrift.protocol.TField schemeField;
+        iprot.readStructBegin();
+        while (true)
+        {
+          schemeField = iprot.readFieldBegin();
+          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
+            break;
+          }
+          switch (schemeField.id) {
+            case 0: // SUCCESS
+              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
+                struct.success = new TGetLogResp();
+                struct.success.read(iprot);
+                struct.setSuccessIsSet(true);
+              } else { 
+                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
+              }
+              break;
+            default:
+              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
+          }
+          iprot.readFieldEnd();
+        }
+        iprot.readStructEnd();
+        struct.validate();
+      }
+
+      public void write(org.apache.thrift.protocol.TProtocol oprot, GetLog_result struct) throws org.apache.thrift.TException {
+        struct.validate();
+
+        oprot.writeStructBegin(STRUCT_DESC);
+        if (struct.success != null) {
+          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
+          struct.success.write(oprot);
+          oprot.writeFieldEnd();
+        }
+        oprot.writeFieldStop();
+        oprot.writeStructEnd();
+      }
+
+    }
+
+    private static class GetLog_resultTupleSchemeFactory implements SchemeFactory {
+      public GetLog_resultTupleScheme getScheme() {
+        return new GetLog_resultTupleScheme();
+      }
+    }
+
+    private static class GetLog_resultTupleScheme extends TupleScheme<GetLog_result> {
+
+      @Override
+      public void write(org.apache.thrift.protocol.TProtocol prot, GetLog_result struct) throws org.apache.thrift.TException {
+        TTupleProtocol oprot = (TTupleProtocol) prot;
+        BitSet optionals = new BitSet();
+        if (struct.isSetSuccess()) {
+          optionals.set(0);
+        }
+        oprot.writeBitSet(optionals, 1);
+        if (struct.isSetSuccess()) {
+          struct.success.write(oprot);
+        }
+      }
+
+      @Override
+      public void read(org.apache.thrift.protocol.TProtocol prot, GetLog_result struct) throws org.apache.thrift.TException {
+        TTupleProtocol iprot = (TTupleProtocol) prot;
+        BitSet incoming = iprot.readBitSet(1);
+        if (incoming.get(0)) {
+          struct.success = new TGetLogResp();
+          struct.success.read(iprot);
+          struct.setSuccessIsSet(true);
+        }
+      }
+    }
+
+  }
+
 }
diff --git a/src/service/src/gen/thrift/gen-javabean/org/apache/hive/service/cli/thrift/TExecuteStatementReq.java b/src/service/src/gen/thrift/gen-javabean/org/apache/hive/service/cli/thrift/TExecuteStatementReq.java
index 24568a1..a55b464 100644
--- a/src/service/src/gen/thrift/gen-javabean/org/apache/hive/service/cli/thrift/TExecuteStatementReq.java
+++ b/src/service/src/gen/thrift/gen-javabean/org/apache/hive/service/cli/thrift/TExecuteStatementReq.java
@@ -547,7 +547,7 @@ public class TExecuteStatementReq implements org.apache.thrift.TBase<TExecuteSta
                 for (int _i145 = 0; _i145 < _map144.size; ++_i145)
                 {
                   String _key146; // required
-                  String _val147; // required
+                  String _val147; // optional
                   _key146 = iprot.readString();
                   _val147 = iprot.readString();
                   struct.confOverlay.put(_key146, _val147);
@@ -649,7 +649,7 @@ public class TExecuteStatementReq implements org.apache.thrift.TBase<TExecuteSta
           for (int _i151 = 0; _i151 < _map150.size; ++_i151)
           {
             String _key152; // required
-            String _val153; // required
+            String _val153; // optional
             _key152 = iprot.readString();
             _val153 = iprot.readString();
             struct.confOverlay.put(_key152, _val153);
diff --git a/src/service/src/gen/thrift/gen-javabean/org/apache/hive/service/cli/thrift/TGetLogReq.java b/src/service/src/gen/thrift/gen-javabean/org/apache/hive/service/cli/thrift/TGetLogReq.java
new file mode 100644
index 0000000..48cd64f
--- /dev/null
+++ b/src/service/src/gen/thrift/gen-javabean/org/apache/hive/service/cli/thrift/TGetLogReq.java
@@ -0,0 +1,390 @@
+/**
+ * Autogenerated by Thrift Compiler (0.9.0)
+ *
+ * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
+ *  @generated
+ */
+package org.apache.hive.service.cli.thrift;
+
+import org.apache.commons.lang.builder.HashCodeBuilder;
+import org.apache.thrift.scheme.IScheme;
+import org.apache.thrift.scheme.SchemeFactory;
+import org.apache.thrift.scheme.StandardScheme;
+
+import org.apache.thrift.scheme.TupleScheme;
+import org.apache.thrift.protocol.TTupleProtocol;
+import org.apache.thrift.protocol.TProtocolException;
+import org.apache.thrift.EncodingUtils;
+import org.apache.thrift.TException;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Map;
+import java.util.HashMap;
+import java.util.EnumMap;
+import java.util.Set;
+import java.util.HashSet;
+import java.util.EnumSet;
+import java.util.Collections;
+import java.util.BitSet;
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class TGetLogReq implements org.apache.thrift.TBase<TGetLogReq, TGetLogReq._Fields>, java.io.Serializable, Cloneable {
+  private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("TGetLogReq");
+
+  private static final org.apache.thrift.protocol.TField OPERATION_HANDLE_FIELD_DESC = new org.apache.thrift.protocol.TField("operationHandle", org.apache.thrift.protocol.TType.STRUCT, (short)1);
+
+  private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
+  static {
+    schemes.put(StandardScheme.class, new TGetLogReqStandardSchemeFactory());
+    schemes.put(TupleScheme.class, new TGetLogReqTupleSchemeFactory());
+  }
+
+  private TOperationHandle operationHandle; // required
+
+  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
+  public enum _Fields implements org.apache.thrift.TFieldIdEnum {
+    OPERATION_HANDLE((short)1, "operationHandle");
+
+    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
+
+    static {
+      for (_Fields field : EnumSet.allOf(_Fields.class)) {
+        byName.put(field.getFieldName(), field);
+      }
+    }
+
+    /**
+     * Find the _Fields constant that matches fieldId, or null if its not found.
+     */
+    public static _Fields findByThriftId(int fieldId) {
+      switch(fieldId) {
+        case 1: // OPERATION_HANDLE
+          return OPERATION_HANDLE;
+        default:
+          return null;
+      }
+    }
+
+    /**
+     * Find the _Fields constant that matches fieldId, throwing an exception
+     * if it is not found.
+     */
+    public static _Fields findByThriftIdOrThrow(int fieldId) {
+      _Fields fields = findByThriftId(fieldId);
+      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
+      return fields;
+    }
+
+    /**
+     * Find the _Fields constant that matches name, or null if its not found.
+     */
+    public static _Fields findByName(String name) {
+      return byName.get(name);
+    }
+
+    private final short _thriftId;
+    private final String _fieldName;
+
+    _Fields(short thriftId, String fieldName) {
+      _thriftId = thriftId;
+      _fieldName = fieldName;
+    }
+
+    public short getThriftFieldId() {
+      return _thriftId;
+    }
+
+    public String getFieldName() {
+      return _fieldName;
+    }
+  }
+
+  // isset id assignments
+  public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
+  static {
+    Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
+    tmpMap.put(_Fields.OPERATION_HANDLE, new org.apache.thrift.meta_data.FieldMetaData("operationHandle", org.apache.thrift.TFieldRequirementType.REQUIRED, 
+        new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, TOperationHandle.class)));
+    metaDataMap = Collections.unmodifiableMap(tmpMap);
+    org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(TGetLogReq.class, metaDataMap);
+  }
+
+  public TGetLogReq() {
+  }
+
+  public TGetLogReq(
+    TOperationHandle operationHandle)
+  {
+    this();
+    this.operationHandle = operationHandle;
+  }
+
+  /**
+   * Performs a deep copy on <i>other</i>.
+   */
+  public TGetLogReq(TGetLogReq other) {
+    if (other.isSetOperationHandle()) {
+      this.operationHandle = new TOperationHandle(other.operationHandle);
+    }
+  }
+
+  public TGetLogReq deepCopy() {
+    return new TGetLogReq(this);
+  }
+
+  @Override
+  public void clear() {
+    this.operationHandle = null;
+  }
+
+  public TOperationHandle getOperationHandle() {
+    return this.operationHandle;
+  }
+
+  public void setOperationHandle(TOperationHandle operationHandle) {
+    this.operationHandle = operationHandle;
+  }
+
+  public void unsetOperationHandle() {
+    this.operationHandle = null;
+  }
+
+  /** Returns true if field operationHandle is set (has been assigned a value) and false otherwise */
+  public boolean isSetOperationHandle() {
+    return this.operationHandle != null;
+  }
+
+  public void setOperationHandleIsSet(boolean value) {
+    if (!value) {
+      this.operationHandle = null;
+    }
+  }
+
+  public void setFieldValue(_Fields field, Object value) {
+    switch (field) {
+    case OPERATION_HANDLE:
+      if (value == null) {
+        unsetOperationHandle();
+      } else {
+        setOperationHandle((TOperationHandle)value);
+      }
+      break;
+
+    }
+  }
+
+  public Object getFieldValue(_Fields field) {
+    switch (field) {
+    case OPERATION_HANDLE:
+      return getOperationHandle();
+
+    }
+    throw new IllegalStateException();
+  }
+
+  /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
+  public boolean isSet(_Fields field) {
+    if (field == null) {
+      throw new IllegalArgumentException();
+    }
+
+    switch (field) {
+    case OPERATION_HANDLE:
+      return isSetOperationHandle();
+    }
+    throw new IllegalStateException();
+  }
+
+  @Override
+  public boolean equals(Object that) {
+    if (that == null)
+      return false;
+    if (that instanceof TGetLogReq)
+      return this.equals((TGetLogReq)that);
+    return false;
+  }
+
+  public boolean equals(TGetLogReq that) {
+    if (that == null)
+      return false;
+
+    boolean this_present_operationHandle = true && this.isSetOperationHandle();
+    boolean that_present_operationHandle = true && that.isSetOperationHandle();
+    if (this_present_operationHandle || that_present_operationHandle) {
+      if (!(this_present_operationHandle && that_present_operationHandle))
+        return false;
+      if (!this.operationHandle.equals(that.operationHandle))
+        return false;
+    }
+
+    return true;
+  }
+
+  @Override
+  public int hashCode() {
+    HashCodeBuilder builder = new HashCodeBuilder();
+
+    boolean present_operationHandle = true && (isSetOperationHandle());
+    builder.append(present_operationHandle);
+    if (present_operationHandle)
+      builder.append(operationHandle);
+
+    return builder.toHashCode();
+  }
+
+  public int compareTo(TGetLogReq other) {
+    if (!getClass().equals(other.getClass())) {
+      return getClass().getName().compareTo(other.getClass().getName());
+    }
+
+    int lastComparison = 0;
+    TGetLogReq typedOther = (TGetLogReq)other;
+
+    lastComparison = Boolean.valueOf(isSetOperationHandle()).compareTo(typedOther.isSetOperationHandle());
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    if (isSetOperationHandle()) {
+      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.operationHandle, typedOther.operationHandle);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+    }
+    return 0;
+  }
+
+  public _Fields fieldForId(int fieldId) {
+    return _Fields.findByThriftId(fieldId);
+  }
+
+  public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
+    schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
+  }
+
+  public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
+    schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder sb = new StringBuilder("TGetLogReq(");
+    boolean first = true;
+
+    sb.append("operationHandle:");
+    if (this.operationHandle == null) {
+      sb.append("null");
+    } else {
+      sb.append(this.operationHandle);
+    }
+    first = false;
+    sb.append(")");
+    return sb.toString();
+  }
+
+  public void validate() throws org.apache.thrift.TException {
+    // check for required fields
+    if (!isSetOperationHandle()) {
+      throw new org.apache.thrift.protocol.TProtocolException("Required field 'operationHandle' is unset! Struct:" + toString());
+    }
+
+    // check for sub-struct validity
+    if (operationHandle != null) {
+      operationHandle.validate();
+    }
+  }
+
+  private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
+    try {
+      write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
+    } catch (org.apache.thrift.TException te) {
+      throw new java.io.IOException(te);
+    }
+  }
+
+  private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
+    try {
+      read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
+    } catch (org.apache.thrift.TException te) {
+      throw new java.io.IOException(te);
+    }
+  }
+
+  private static class TGetLogReqStandardSchemeFactory implements SchemeFactory {
+    public TGetLogReqStandardScheme getScheme() {
+      return new TGetLogReqStandardScheme();
+    }
+  }
+
+  private static class TGetLogReqStandardScheme extends StandardScheme<TGetLogReq> {
+
+    public void read(org.apache.thrift.protocol.TProtocol iprot, TGetLogReq struct) throws org.apache.thrift.TException {
+      org.apache.thrift.protocol.TField schemeField;
+      iprot.readStructBegin();
+      while (true)
+      {
+        schemeField = iprot.readFieldBegin();
+        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
+          break;
+        }
+        switch (schemeField.id) {
+          case 1: // OPERATION_HANDLE
+            if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
+              struct.operationHandle = new TOperationHandle();
+              struct.operationHandle.read(iprot);
+              struct.setOperationHandleIsSet(true);
+            } else { 
+              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
+            }
+            break;
+          default:
+            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
+        }
+        iprot.readFieldEnd();
+      }
+      iprot.readStructEnd();
+      struct.validate();
+    }
+
+    public void write(org.apache.thrift.protocol.TProtocol oprot, TGetLogReq struct) throws org.apache.thrift.TException {
+      struct.validate();
+
+      oprot.writeStructBegin(STRUCT_DESC);
+      if (struct.operationHandle != null) {
+        oprot.writeFieldBegin(OPERATION_HANDLE_FIELD_DESC);
+        struct.operationHandle.write(oprot);
+        oprot.writeFieldEnd();
+      }
+      oprot.writeFieldStop();
+      oprot.writeStructEnd();
+    }
+
+  }
+
+  private static class TGetLogReqTupleSchemeFactory implements SchemeFactory {
+    public TGetLogReqTupleScheme getScheme() {
+      return new TGetLogReqTupleScheme();
+    }
+  }
+
+  private static class TGetLogReqTupleScheme extends TupleScheme<TGetLogReq> {
+
+    @Override
+    public void write(org.apache.thrift.protocol.TProtocol prot, TGetLogReq struct) throws org.apache.thrift.TException {
+      TTupleProtocol oprot = (TTupleProtocol) prot;
+      struct.operationHandle.write(oprot);
+    }
+
+    @Override
+    public void read(org.apache.thrift.protocol.TProtocol prot, TGetLogReq struct) throws org.apache.thrift.TException {
+      TTupleProtocol iprot = (TTupleProtocol) prot;
+      struct.operationHandle = new TOperationHandle();
+      struct.operationHandle.read(iprot);
+      struct.setOperationHandleIsSet(true);
+    }
+  }
+
+}
+
diff --git a/src/service/src/gen/thrift/gen-javabean/org/apache/hive/service/cli/thrift/TGetLogResp.java b/src/service/src/gen/thrift/gen-javabean/org/apache/hive/service/cli/thrift/TGetLogResp.java
new file mode 100644
index 0000000..a9e5a4b
--- /dev/null
+++ b/src/service/src/gen/thrift/gen-javabean/org/apache/hive/service/cli/thrift/TGetLogResp.java
@@ -0,0 +1,491 @@
+/**
+ * Autogenerated by Thrift Compiler (0.9.0)
+ *
+ * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
+ *  @generated
+ */
+package org.apache.hive.service.cli.thrift;
+
+import org.apache.commons.lang.builder.HashCodeBuilder;
+import org.apache.thrift.scheme.IScheme;
+import org.apache.thrift.scheme.SchemeFactory;
+import org.apache.thrift.scheme.StandardScheme;
+
+import org.apache.thrift.scheme.TupleScheme;
+import org.apache.thrift.protocol.TTupleProtocol;
+import org.apache.thrift.protocol.TProtocolException;
+import org.apache.thrift.EncodingUtils;
+import org.apache.thrift.TException;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Map;
+import java.util.HashMap;
+import java.util.EnumMap;
+import java.util.Set;
+import java.util.HashSet;
+import java.util.EnumSet;
+import java.util.Collections;
+import java.util.BitSet;
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class TGetLogResp implements org.apache.thrift.TBase<TGetLogResp, TGetLogResp._Fields>, java.io.Serializable, Cloneable {
+  private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("TGetLogResp");
+
+  private static final org.apache.thrift.protocol.TField STATUS_FIELD_DESC = new org.apache.thrift.protocol.TField("status", org.apache.thrift.protocol.TType.STRUCT, (short)1);
+  private static final org.apache.thrift.protocol.TField LOG_FIELD_DESC = new org.apache.thrift.protocol.TField("log", org.apache.thrift.protocol.TType.STRING, (short)2);
+
+  private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
+  static {
+    schemes.put(StandardScheme.class, new TGetLogRespStandardSchemeFactory());
+    schemes.put(TupleScheme.class, new TGetLogRespTupleSchemeFactory());
+  }
+
+  private TStatus status; // required
+  private String log; // required
+
+  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
+  public enum _Fields implements org.apache.thrift.TFieldIdEnum {
+    STATUS((short)1, "status"),
+    LOG((short)2, "log");
+
+    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
+
+    static {
+      for (_Fields field : EnumSet.allOf(_Fields.class)) {
+        byName.put(field.getFieldName(), field);
+      }
+    }
+
+    /**
+     * Find the _Fields constant that matches fieldId, or null if its not found.
+     */
+    public static _Fields findByThriftId(int fieldId) {
+      switch(fieldId) {
+        case 1: // STATUS
+          return STATUS;
+        case 2: // LOG
+          return LOG;
+        default:
+          return null;
+      }
+    }
+
+    /**
+     * Find the _Fields constant that matches fieldId, throwing an exception
+     * if it is not found.
+     */
+    public static _Fields findByThriftIdOrThrow(int fieldId) {
+      _Fields fields = findByThriftId(fieldId);
+      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
+      return fields;
+    }
+
+    /**
+     * Find the _Fields constant that matches name, or null if its not found.
+     */
+    public static _Fields findByName(String name) {
+      return byName.get(name);
+    }
+
+    private final short _thriftId;
+    private final String _fieldName;
+
+    _Fields(short thriftId, String fieldName) {
+      _thriftId = thriftId;
+      _fieldName = fieldName;
+    }
+
+    public short getThriftFieldId() {
+      return _thriftId;
+    }
+
+    public String getFieldName() {
+      return _fieldName;
+    }
+  }
+
+  // isset id assignments
+  public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
+  static {
+    Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
+    tmpMap.put(_Fields.STATUS, new org.apache.thrift.meta_data.FieldMetaData("status", org.apache.thrift.TFieldRequirementType.REQUIRED, 
+        new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, TStatus.class)));
+    tmpMap.put(_Fields.LOG, new org.apache.thrift.meta_data.FieldMetaData("log", org.apache.thrift.TFieldRequirementType.REQUIRED, 
+        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
+    metaDataMap = Collections.unmodifiableMap(tmpMap);
+    org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(TGetLogResp.class, metaDataMap);
+  }
+
+  public TGetLogResp() {
+  }
+
+  public TGetLogResp(
+    TStatus status,
+    String log)
+  {
+    this();
+    this.status = status;
+    this.log = log;
+  }
+
+  /**
+   * Performs a deep copy on <i>other</i>.
+   */
+  public TGetLogResp(TGetLogResp other) {
+    if (other.isSetStatus()) {
+      this.status = new TStatus(other.status);
+    }
+    if (other.isSetLog()) {
+      this.log = other.log;
+    }
+  }
+
+  public TGetLogResp deepCopy() {
+    return new TGetLogResp(this);
+  }
+
+  @Override
+  public void clear() {
+    this.status = null;
+    this.log = null;
+  }
+
+  public TStatus getStatus() {
+    return this.status;
+  }
+
+  public void setStatus(TStatus status) {
+    this.status = status;
+  }
+
+  public void unsetStatus() {
+    this.status = null;
+  }
+
+  /** Returns true if field status is set (has been assigned a value) and false otherwise */
+  public boolean isSetStatus() {
+    return this.status != null;
+  }
+
+  public void setStatusIsSet(boolean value) {
+    if (!value) {
+      this.status = null;
+    }
+  }
+
+  public String getLog() {
+    return this.log;
+  }
+
+  public void setLog(String log) {
+    this.log = log;
+  }
+
+  public void unsetLog() {
+    this.log = null;
+  }
+
+  /** Returns true if field log is set (has been assigned a value) and false otherwise */
+  public boolean isSetLog() {
+    return this.log != null;
+  }
+
+  public void setLogIsSet(boolean value) {
+    if (!value) {
+      this.log = null;
+    }
+  }
+
+  public void setFieldValue(_Fields field, Object value) {
+    switch (field) {
+    case STATUS:
+      if (value == null) {
+        unsetStatus();
+      } else {
+        setStatus((TStatus)value);
+      }
+      break;
+
+    case LOG:
+      if (value == null) {
+        unsetLog();
+      } else {
+        setLog((String)value);
+      }
+      break;
+
+    }
+  }
+
+  public Object getFieldValue(_Fields field) {
+    switch (field) {
+    case STATUS:
+      return getStatus();
+
+    case LOG:
+      return getLog();
+
+    }
+    throw new IllegalStateException();
+  }
+
+  /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
+  public boolean isSet(_Fields field) {
+    if (field == null) {
+      throw new IllegalArgumentException();
+    }
+
+    switch (field) {
+    case STATUS:
+      return isSetStatus();
+    case LOG:
+      return isSetLog();
+    }
+    throw new IllegalStateException();
+  }
+
+  @Override
+  public boolean equals(Object that) {
+    if (that == null)
+      return false;
+    if (that instanceof TGetLogResp)
+      return this.equals((TGetLogResp)that);
+    return false;
+  }
+
+  public boolean equals(TGetLogResp that) {
+    if (that == null)
+      return false;
+
+    boolean this_present_status = true && this.isSetStatus();
+    boolean that_present_status = true && that.isSetStatus();
+    if (this_present_status || that_present_status) {
+      if (!(this_present_status && that_present_status))
+        return false;
+      if (!this.status.equals(that.status))
+        return false;
+    }
+
+    boolean this_present_log = true && this.isSetLog();
+    boolean that_present_log = true && that.isSetLog();
+    if (this_present_log || that_present_log) {
+      if (!(this_present_log && that_present_log))
+        return false;
+      if (!this.log.equals(that.log))
+        return false;
+    }
+
+    return true;
+  }
+
+  @Override
+  public int hashCode() {
+    HashCodeBuilder builder = new HashCodeBuilder();
+
+    boolean present_status = true && (isSetStatus());
+    builder.append(present_status);
+    if (present_status)
+      builder.append(status);
+
+    boolean present_log = true && (isSetLog());
+    builder.append(present_log);
+    if (present_log)
+      builder.append(log);
+
+    return builder.toHashCode();
+  }
+
+  public int compareTo(TGetLogResp other) {
+    if (!getClass().equals(other.getClass())) {
+      return getClass().getName().compareTo(other.getClass().getName());
+    }
+
+    int lastComparison = 0;
+    TGetLogResp typedOther = (TGetLogResp)other;
+
+    lastComparison = Boolean.valueOf(isSetStatus()).compareTo(typedOther.isSetStatus());
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    if (isSetStatus()) {
+      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.status, typedOther.status);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+    }
+    lastComparison = Boolean.valueOf(isSetLog()).compareTo(typedOther.isSetLog());
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    if (isSetLog()) {
+      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.log, typedOther.log);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+    }
+    return 0;
+  }
+
+  public _Fields fieldForId(int fieldId) {
+    return _Fields.findByThriftId(fieldId);
+  }
+
+  public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
+    schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
+  }
+
+  public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
+    schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder sb = new StringBuilder("TGetLogResp(");
+    boolean first = true;
+
+    sb.append("status:");
+    if (this.status == null) {
+      sb.append("null");
+    } else {
+      sb.append(this.status);
+    }
+    first = false;
+    if (!first) sb.append(", ");
+    sb.append("log:");
+    if (this.log == null) {
+      sb.append("null");
+    } else {
+      sb.append(this.log);
+    }
+    first = false;
+    sb.append(")");
+    return sb.toString();
+  }
+
+  public void validate() throws org.apache.thrift.TException {
+    // check for required fields
+    if (!isSetStatus()) {
+      throw new org.apache.thrift.protocol.TProtocolException("Required field 'status' is unset! Struct:" + toString());
+    }
+
+    if (!isSetLog()) {
+      throw new org.apache.thrift.protocol.TProtocolException("Required field 'log' is unset! Struct:" + toString());
+    }
+
+    // check for sub-struct validity
+    if (status != null) {
+      status.validate();
+    }
+  }
+
+  private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
+    try {
+      write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
+    } catch (org.apache.thrift.TException te) {
+      throw new java.io.IOException(te);
+    }
+  }
+
+  private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
+    try {
+      read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
+    } catch (org.apache.thrift.TException te) {
+      throw new java.io.IOException(te);
+    }
+  }
+
+  private static class TGetLogRespStandardSchemeFactory implements SchemeFactory {
+    public TGetLogRespStandardScheme getScheme() {
+      return new TGetLogRespStandardScheme();
+    }
+  }
+
+  private static class TGetLogRespStandardScheme extends StandardScheme<TGetLogResp> {
+
+    public void read(org.apache.thrift.protocol.TProtocol iprot, TGetLogResp struct) throws org.apache.thrift.TException {
+      org.apache.thrift.protocol.TField schemeField;
+      iprot.readStructBegin();
+      while (true)
+      {
+        schemeField = iprot.readFieldBegin();
+        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
+          break;
+        }
+        switch (schemeField.id) {
+          case 1: // STATUS
+            if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
+              struct.status = new TStatus();
+              struct.status.read(iprot);
+              struct.setStatusIsSet(true);
+            } else { 
+              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
+            }
+            break;
+          case 2: // LOG
+            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
+              struct.log = iprot.readString();
+              struct.setLogIsSet(true);
+            } else { 
+              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
+            }
+            break;
+          default:
+            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
+        }
+        iprot.readFieldEnd();
+      }
+      iprot.readStructEnd();
+      struct.validate();
+    }
+
+    public void write(org.apache.thrift.protocol.TProtocol oprot, TGetLogResp struct) throws org.apache.thrift.TException {
+      struct.validate();
+
+      oprot.writeStructBegin(STRUCT_DESC);
+      if (struct.status != null) {
+        oprot.writeFieldBegin(STATUS_FIELD_DESC);
+        struct.status.write(oprot);
+        oprot.writeFieldEnd();
+      }
+      if (struct.log != null) {
+        oprot.writeFieldBegin(LOG_FIELD_DESC);
+        oprot.writeString(struct.log);
+        oprot.writeFieldEnd();
+      }
+      oprot.writeFieldStop();
+      oprot.writeStructEnd();
+    }
+
+  }
+
+  private static class TGetLogRespTupleSchemeFactory implements SchemeFactory {
+    public TGetLogRespTupleScheme getScheme() {
+      return new TGetLogRespTupleScheme();
+    }
+  }
+
+  private static class TGetLogRespTupleScheme extends TupleScheme<TGetLogResp> {
+
+    @Override
+    public void write(org.apache.thrift.protocol.TProtocol prot, TGetLogResp struct) throws org.apache.thrift.TException {
+      TTupleProtocol oprot = (TTupleProtocol) prot;
+      struct.status.write(oprot);
+      oprot.writeString(struct.log);
+    }
+
+    @Override
+    public void read(org.apache.thrift.protocol.TProtocol prot, TGetLogResp struct) throws org.apache.thrift.TException {
+      TTupleProtocol iprot = (TTupleProtocol) prot;
+      struct.status = new TStatus();
+      struct.status.read(iprot);
+      struct.setStatusIsSet(true);
+      struct.log = iprot.readString();
+      struct.setLogIsSet(true);
+    }
+  }
+
+}
+
diff --git a/src/service/src/gen/thrift/gen-javabean/org/apache/hive/service/cli/thrift/TOpenSessionReq.java b/src/service/src/gen/thrift/gen-javabean/org/apache/hive/service/cli/thrift/TOpenSessionReq.java
index d026adf..59c3817 100644
--- a/src/service/src/gen/thrift/gen-javabean/org/apache/hive/service/cli/thrift/TOpenSessionReq.java
+++ b/src/service/src/gen/thrift/gen-javabean/org/apache/hive/service/cli/thrift/TOpenSessionReq.java
@@ -643,7 +643,7 @@ public class TOpenSessionReq implements org.apache.thrift.TBase<TOpenSessionReq,
                 for (int _i125 = 0; _i125 < _map124.size; ++_i125)
                 {
                   String _key126; // required
-                  String _val127; // required
+                  String _val127; // optional
                   _key126 = iprot.readString();
                   _val127 = iprot.readString();
                   struct.configuration.put(_key126, _val127);
@@ -770,7 +770,7 @@ public class TOpenSessionReq implements org.apache.thrift.TBase<TOpenSessionReq,
           for (int _i131 = 0; _i131 < _map130.size; ++_i131)
           {
             String _key132; // required
-            String _val133; // required
+            String _val133; // optional
             _key132 = iprot.readString();
             _val133 = iprot.readString();
             struct.configuration.put(_key132, _val133);
diff --git a/src/service/src/gen/thrift/gen-javabean/org/apache/hive/service/cli/thrift/TOpenSessionResp.java b/src/service/src/gen/thrift/gen-javabean/org/apache/hive/service/cli/thrift/TOpenSessionResp.java
index e70d63a..af21391 100644
--- a/src/service/src/gen/thrift/gen-javabean/org/apache/hive/service/cli/thrift/TOpenSessionResp.java
+++ b/src/service/src/gen/thrift/gen-javabean/org/apache/hive/service/cli/thrift/TOpenSessionResp.java
@@ -655,7 +655,7 @@ public class TOpenSessionResp implements org.apache.thrift.TBase<TOpenSessionRes
                 for (int _i135 = 0; _i135 < _map134.size; ++_i135)
                 {
                   String _key136; // required
-                  String _val137; // required
+                  String _val137; // optional
                   _key136 = iprot.readString();
                   _val137 = iprot.readString();
                   struct.configuration.put(_key136, _val137);
@@ -775,7 +775,7 @@ public class TOpenSessionResp implements org.apache.thrift.TBase<TOpenSessionRes
           for (int _i141 = 0; _i141 < _map140.size; ++_i141)
           {
             String _key142; // required
-            String _val143; // required
+            String _val143; // optional
             _key142 = iprot.readString();
             _val143 = iprot.readString();
             struct.configuration.put(_key142, _val143);
diff --git a/src/service/src/gen/thrift/gen-javabean/org/apache/hive/service/cli/thrift/TStructTypeEntry.java b/src/service/src/gen/thrift/gen-javabean/org/apache/hive/service/cli/thrift/TStructTypeEntry.java
index d12238f..f3e43b5 100644
--- a/src/service/src/gen/thrift/gen-javabean/org/apache/hive/service/cli/thrift/TStructTypeEntry.java
+++ b/src/service/src/gen/thrift/gen-javabean/org/apache/hive/service/cli/thrift/TStructTypeEntry.java
@@ -360,7 +360,7 @@ public class TStructTypeEntry implements org.apache.thrift.TBase<TStructTypeEntr
                 for (int _i1 = 0; _i1 < _map0.size; ++_i1)
                 {
                   String _key2; // required
-                  int _val3; // required
+                  int _val3; // optional
                   _key2 = iprot.readString();
                   _val3 = iprot.readI32();
                   struct.nameToTypePtr.put(_key2, _val3);
@@ -434,7 +434,7 @@ public class TStructTypeEntry implements org.apache.thrift.TBase<TStructTypeEntr
         for (int _i7 = 0; _i7 < _map6.size; ++_i7)
         {
           String _key8; // required
-          int _val9; // required
+          int _val9; // optional
           _key8 = iprot.readString();
           _val9 = iprot.readI32();
           struct.nameToTypePtr.put(_key8, _val9);
diff --git a/src/service/src/gen/thrift/gen-javabean/org/apache/hive/service/cli/thrift/TUnionTypeEntry.java b/src/service/src/gen/thrift/gen-javabean/org/apache/hive/service/cli/thrift/TUnionTypeEntry.java
index 9254547..43528ac 100644
--- a/src/service/src/gen/thrift/gen-javabean/org/apache/hive/service/cli/thrift/TUnionTypeEntry.java
+++ b/src/service/src/gen/thrift/gen-javabean/org/apache/hive/service/cli/thrift/TUnionTypeEntry.java
@@ -360,7 +360,7 @@ public class TUnionTypeEntry implements org.apache.thrift.TBase<TUnionTypeEntry,
                 for (int _i11 = 0; _i11 < _map10.size; ++_i11)
                 {
                   String _key12; // required
-                  int _val13; // required
+                  int _val13; // optional
                   _key12 = iprot.readString();
                   _val13 = iprot.readI32();
                   struct.nameToTypePtr.put(_key12, _val13);
@@ -434,7 +434,7 @@ public class TUnionTypeEntry implements org.apache.thrift.TBase<TUnionTypeEntry,
         for (int _i17 = 0; _i17 < _map16.size; ++_i17)
         {
           String _key18; // required
-          int _val19; // required
+          int _val19; // optional
           _key18 = iprot.readString();
           _val19 = iprot.readI32();
           struct.nameToTypePtr.put(_key18, _val19);
diff --git a/src/service/src/gen/thrift/gen-php/TCLIService.php b/src/service/src/gen/thrift/gen-php/TCLIService.php
index bbb6b0f..1e51c75 100644
--- a/src/service/src/gen/thrift/gen-php/TCLIService.php
+++ b/src/service/src/gen/thrift/gen-php/TCLIService.php
@@ -32,6 +32,7 @@ interface TCLIServiceIf {
   public function CloseOperation(\TCloseOperationReq $req);
   public function GetResultSetMetadata(\TGetResultSetMetadataReq $req);
   public function FetchResults(\TFetchResultsReq $req);
+  public function GetLog(\TGetLogReq $req);
 }
 
 class TCLIServiceClient implements \TCLIServiceIf {
@@ -861,6 +862,57 @@ class TCLIServiceClient implements \TCLIServiceIf {
     throw new \Exception("FetchResults failed: unknown result");
   }
 
+  public function GetLog(\TGetLogReq $req)
+  {
+    $this->send_GetLog($req);
+    return $this->recv_GetLog();
+  }
+
+  public function send_GetLog(\TGetLogReq $req)
+  {
+    $args = new \TCLIService_GetLog_args();
+    $args->req = $req;
+    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
+    if ($bin_accel)
+    {
+      thrift_protocol_write_binary($this->output_, 'GetLog', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
+    }
+    else
+    {
+      $this->output_->writeMessageBegin('GetLog', TMessageType::CALL, $this->seqid_);
+      $args->write($this->output_);
+      $this->output_->writeMessageEnd();
+      $this->output_->getTransport()->flush();
+    }
+  }
+
+  public function recv_GetLog()
+  {
+    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
+    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\TCLIService_GetLog_result', $this->input_->isStrictRead());
+    else
+    {
+      $rseqid = 0;
+      $fname = null;
+      $mtype = 0;
+
+      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
+      if ($mtype == TMessageType::EXCEPTION) {
+        $x = new TApplicationException();
+        $x->read($this->input_);
+        $this->input_->readMessageEnd();
+        throw $x;
+      }
+      $result = new \TCLIService_GetLog_result();
+      $result->read($this->input_);
+      $this->input_->readMessageEnd();
+    }
+    if ($result->success !== null) {
+      return $result->success;
+    }
+    throw new \Exception("GetLog failed: unknown result");
+  }
+
 }
 
 // HELPER FUNCTIONS AND STRUCTURES
@@ -3329,4 +3381,158 @@ class TCLIService_FetchResults_result {
 
 }
 
+class TCLIService_GetLog_args {
+  static $_TSPEC;
+
+  public $req = null;
+
+  public function __construct($vals=null) {
+    if (!isset(self::$_TSPEC)) {
+      self::$_TSPEC = array(
+        1 => array(
+          'var' => 'req',
+          'type' => TType::STRUCT,
+          'class' => '\TGetLogReq',
+          ),
+        );
+    }
+    if (is_array($vals)) {
+      if (isset($vals['req'])) {
+        $this->req = $vals['req'];
+      }
+    }
+  }
+
+  public function getName() {
+    return 'TCLIService_GetLog_args';
+  }
+
+  public function read($input)
+  {
+    $xfer = 0;
+    $fname = null;
+    $ftype = 0;
+    $fid = 0;
+    $xfer += $input->readStructBegin($fname);
+    while (true)
+    {
+      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
+      if ($ftype == TType::STOP) {
+        break;
+      }
+      switch ($fid)
+      {
+        case 1:
+          if ($ftype == TType::STRUCT) {
+            $this->req = new \TGetLogReq();
+            $xfer += $this->req->read($input);
+          } else {
+            $xfer += $input->skip($ftype);
+          }
+          break;
+        default:
+          $xfer += $input->skip($ftype);
+          break;
+      }
+      $xfer += $input->readFieldEnd();
+    }
+    $xfer += $input->readStructEnd();
+    return $xfer;
+  }
+
+  public function write($output) {
+    $xfer = 0;
+    $xfer += $output->writeStructBegin('TCLIService_GetLog_args');
+    if ($this->req !== null) {
+      if (!is_object($this->req)) {
+        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
+      }
+      $xfer += $output->writeFieldBegin('req', TType::STRUCT, 1);
+      $xfer += $this->req->write($output);
+      $xfer += $output->writeFieldEnd();
+    }
+    $xfer += $output->writeFieldStop();
+    $xfer += $output->writeStructEnd();
+    return $xfer;
+  }
+
+}
+
+class TCLIService_GetLog_result {
+  static $_TSPEC;
+
+  public $success = null;
+
+  public function __construct($vals=null) {
+    if (!isset(self::$_TSPEC)) {
+      self::$_TSPEC = array(
+        0 => array(
+          'var' => 'success',
+          'type' => TType::STRUCT,
+          'class' => '\TGetLogResp',
+          ),
+        );
+    }
+    if (is_array($vals)) {
+      if (isset($vals['success'])) {
+        $this->success = $vals['success'];
+      }
+    }
+  }
+
+  public function getName() {
+    return 'TCLIService_GetLog_result';
+  }
+
+  public function read($input)
+  {
+    $xfer = 0;
+    $fname = null;
+    $ftype = 0;
+    $fid = 0;
+    $xfer += $input->readStructBegin($fname);
+    while (true)
+    {
+      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
+      if ($ftype == TType::STOP) {
+        break;
+      }
+      switch ($fid)
+      {
+        case 0:
+          if ($ftype == TType::STRUCT) {
+            $this->success = new \TGetLogResp();
+            $xfer += $this->success->read($input);
+          } else {
+            $xfer += $input->skip($ftype);
+          }
+          break;
+        default:
+          $xfer += $input->skip($ftype);
+          break;
+      }
+      $xfer += $input->readFieldEnd();
+    }
+    $xfer += $input->readStructEnd();
+    return $xfer;
+  }
+
+  public function write($output) {
+    $xfer = 0;
+    $xfer += $output->writeStructBegin('TCLIService_GetLog_result');
+    if ($this->success !== null) {
+      if (!is_object($this->success)) {
+        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
+      }
+      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
+      $xfer += $this->success->write($output);
+      $xfer += $output->writeFieldEnd();
+    }
+    $xfer += $output->writeFieldStop();
+    $xfer += $output->writeStructEnd();
+    return $xfer;
+  }
+
+}
+
 
diff --git a/src/service/src/gen/thrift/gen-py/TCLIService/TCLIService-remote b/src/service/src/gen/thrift/gen-py/TCLIService/TCLIService-remote
index ab0d501..3007749 100755
--- a/src/service/src/gen/thrift/gen-py/TCLIService/TCLIService-remote
+++ b/src/service/src/gen/thrift/gen-py/TCLIService/TCLIService-remote
@@ -39,6 +39,7 @@ if len(sys.argv) <= 1 or sys.argv[1] == '--help':
   print '  TCloseOperationResp CloseOperation(TCloseOperationReq req)'
   print '  TGetResultSetMetadataResp GetResultSetMetadata(TGetResultSetMetadataReq req)'
   print '  TFetchResultsResp FetchResults(TFetchResultsReq req)'
+  print '  TGetLogResp GetLog(TGetLogReq req)'
   print ''
   sys.exit(0)
 
@@ -186,6 +187,12 @@ elif cmd == 'FetchResults':
     sys.exit(1)
   pp.pprint(client.FetchResults(eval(args[0]),))
 
+elif cmd == 'GetLog':
+  if len(args) != 1:
+    print 'GetLog requires 1 args'
+    sys.exit(1)
+  pp.pprint(client.GetLog(eval(args[0]),))
+
 else:
   print 'Unrecognized method %s' % cmd
   sys.exit(1)
diff --git a/src/service/src/gen/thrift/gen-py/TCLIService/TCLIService.py b/src/service/src/gen/thrift/gen-py/TCLIService/TCLIService.py
index 6d2255b..cb2c607 100644
--- a/src/service/src/gen/thrift/gen-py/TCLIService/TCLIService.py
+++ b/src/service/src/gen/thrift/gen-py/TCLIService/TCLIService.py
@@ -130,6 +130,13 @@ class Iface:
     """
     pass
 
+  def GetLog(self, req):
+    """
+    Parameters:
+     - req
+    """
+    pass
+
 
 class Client(Iface):
   def __init__(self, iprot, oprot=None):
@@ -618,6 +625,36 @@ class Client(Iface):
       return result.success
     raise TApplicationException(TApplicationException.MISSING_RESULT, "FetchResults failed: unknown result");
 
+  def GetLog(self, req):
+    """
+    Parameters:
+     - req
+    """
+    self.send_GetLog(req)
+    return self.recv_GetLog()
+
+  def send_GetLog(self, req):
+    self._oprot.writeMessageBegin('GetLog', TMessageType.CALL, self._seqid)
+    args = GetLog_args()
+    args.req = req
+    args.write(self._oprot)
+    self._oprot.writeMessageEnd()
+    self._oprot.trans.flush()
+
+  def recv_GetLog(self, ):
+    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
+    if mtype == TMessageType.EXCEPTION:
+      x = TApplicationException()
+      x.read(self._iprot)
+      self._iprot.readMessageEnd()
+      raise x
+    result = GetLog_result()
+    result.read(self._iprot)
+    self._iprot.readMessageEnd()
+    if result.success is not None:
+      return result.success
+    raise TApplicationException(TApplicationException.MISSING_RESULT, "GetLog failed: unknown result");
+
 
 class Processor(Iface, TProcessor):
   def __init__(self, handler):
@@ -639,6 +676,7 @@ class Processor(Iface, TProcessor):
     self._processMap["CloseOperation"] = Processor.process_CloseOperation
     self._processMap["GetResultSetMetadata"] = Processor.process_GetResultSetMetadata
     self._processMap["FetchResults"] = Processor.process_FetchResults
+    self._processMap["GetLog"] = Processor.process_GetLog
 
   def process(self, iprot, oprot):
     (name, type, seqid) = iprot.readMessageBegin()
@@ -831,6 +869,17 @@ class Processor(Iface, TProcessor):
     oprot.writeMessageEnd()
     oprot.trans.flush()
 
+  def process_GetLog(self, seqid, iprot, oprot):
+    args = GetLog_args()
+    args.read(iprot)
+    iprot.readMessageEnd()
+    result = GetLog_result()
+    result.success = self._handler.GetLog(args.req)
+    oprot.writeMessageBegin("GetLog", TMessageType.REPLY, seqid)
+    result.write(oprot)
+    oprot.writeMessageEnd()
+    oprot.trans.flush()
+
 
 # HELPER FUNCTIONS AND STRUCTURES
 
@@ -2769,3 +2818,124 @@ class FetchResults_result:
 
   def __ne__(self, other):
     return not (self == other)
+
+class GetLog_args:
+  """
+  Attributes:
+   - req
+  """
+
+  thrift_spec = (
+    None, # 0
+    (1, TType.STRUCT, 'req', (TGetLogReq, TGetLogReq.thrift_spec), None, ), # 1
+  )
+
+  def __init__(self, req=None,):
+    self.req = req
+
+  def read(self, iprot):
+    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
+      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
+      return
+    iprot.readStructBegin()
+    while True:
+      (fname, ftype, fid) = iprot.readFieldBegin()
+      if ftype == TType.STOP:
+        break
+      if fid == 1:
+        if ftype == TType.STRUCT:
+          self.req = TGetLogReq()
+          self.req.read(iprot)
+        else:
+          iprot.skip(ftype)
+      else:
+        iprot.skip(ftype)
+      iprot.readFieldEnd()
+    iprot.readStructEnd()
+
+  def write(self, oprot):
+    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
+      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
+      return
+    oprot.writeStructBegin('GetLog_args')
+    if self.req is not None:
+      oprot.writeFieldBegin('req', TType.STRUCT, 1)
+      self.req.write(oprot)
+      oprot.writeFieldEnd()
+    oprot.writeFieldStop()
+    oprot.writeStructEnd()
+
+  def validate(self):
+    return
+
+
+  def __repr__(self):
+    L = ['%s=%r' % (key, value)
+      for key, value in self.__dict__.iteritems()]
+    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+  def __eq__(self, other):
+    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+  def __ne__(self, other):
+    return not (self == other)
+
+class GetLog_result:
+  """
+  Attributes:
+   - success
+  """
+
+  thrift_spec = (
+    (0, TType.STRUCT, 'success', (TGetLogResp, TGetLogResp.thrift_spec), None, ), # 0
+  )
+
+  def __init__(self, success=None,):
+    self.success = success
+
+  def read(self, iprot):
+    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
+      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
+      return
+    iprot.readStructBegin()
+    while True:
+      (fname, ftype, fid) = iprot.readFieldBegin()
+      if ftype == TType.STOP:
+        break
+      if fid == 0:
+        if ftype == TType.STRUCT:
+          self.success = TGetLogResp()
+          self.success.read(iprot)
+        else:
+          iprot.skip(ftype)
+      else:
+        iprot.skip(ftype)
+      iprot.readFieldEnd()
+    iprot.readStructEnd()
+
+  def write(self, oprot):
+    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
+      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
+      return
+    oprot.writeStructBegin('GetLog_result')
+    if self.success is not None:
+      oprot.writeFieldBegin('success', TType.STRUCT, 0)
+      self.success.write(oprot)
+      oprot.writeFieldEnd()
+    oprot.writeFieldStop()
+    oprot.writeStructEnd()
+
+  def validate(self):
+    return
+
+
+  def __repr__(self):
+    L = ['%s=%r' % (key, value)
+      for key, value in self.__dict__.iteritems()]
+    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+  def __eq__(self, other):
+    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+  def __ne__(self, other):
+    return not (self == other)
diff --git a/src/service/src/gen/thrift/gen-py/TCLIService/ttypes.py b/src/service/src/gen/thrift/gen-py/TCLIService/ttypes.py
index 171b8c1..12084a0 100644
--- a/src/service/src/gen/thrift/gen-py/TCLIService/ttypes.py
+++ b/src/service/src/gen/thrift/gen-py/TCLIService/ttypes.py
@@ -5056,3 +5056,143 @@ class TFetchResultsResp:
 
   def __ne__(self, other):
     return not (self == other)
+
+class TGetLogReq:
+  """
+  Attributes:
+   - operationHandle
+  """
+
+  thrift_spec = (
+    None, # 0
+    (1, TType.STRUCT, 'operationHandle', (TOperationHandle, TOperationHandle.thrift_spec), None, ), # 1
+  )
+
+  def __init__(self, operationHandle=None,):
+    self.operationHandle = operationHandle
+
+  def read(self, iprot):
+    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
+      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
+      return
+    iprot.readStructBegin()
+    while True:
+      (fname, ftype, fid) = iprot.readFieldBegin()
+      if ftype == TType.STOP:
+        break
+      if fid == 1:
+        if ftype == TType.STRUCT:
+          self.operationHandle = TOperationHandle()
+          self.operationHandle.read(iprot)
+        else:
+          iprot.skip(ftype)
+      else:
+        iprot.skip(ftype)
+      iprot.readFieldEnd()
+    iprot.readStructEnd()
+
+  def write(self, oprot):
+    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
+      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
+      return
+    oprot.writeStructBegin('TGetLogReq')
+    if self.operationHandle is not None:
+      oprot.writeFieldBegin('operationHandle', TType.STRUCT, 1)
+      self.operationHandle.write(oprot)
+      oprot.writeFieldEnd()
+    oprot.writeFieldStop()
+    oprot.writeStructEnd()
+
+  def validate(self):
+    if self.operationHandle is None:
+      raise TProtocol.TProtocolException(message='Required field operationHandle is unset!')
+    return
+
+
+  def __repr__(self):
+    L = ['%s=%r' % (key, value)
+      for key, value in self.__dict__.iteritems()]
+    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+  def __eq__(self, other):
+    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+  def __ne__(self, other):
+    return not (self == other)
+
+class TGetLogResp:
+  """
+  Attributes:
+   - status
+   - log
+  """
+
+  thrift_spec = (
+    None, # 0
+    (1, TType.STRUCT, 'status', (TStatus, TStatus.thrift_spec), None, ), # 1
+    (2, TType.STRING, 'log', None, None, ), # 2
+  )
+
+  def __init__(self, status=None, log=None,):
+    self.status = status
+    self.log = log
+
+  def read(self, iprot):
+    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
+      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
+      return
+    iprot.readStructBegin()
+    while True:
+      (fname, ftype, fid) = iprot.readFieldBegin()
+      if ftype == TType.STOP:
+        break
+      if fid == 1:
+        if ftype == TType.STRUCT:
+          self.status = TStatus()
+          self.status.read(iprot)
+        else:
+          iprot.skip(ftype)
+      elif fid == 2:
+        if ftype == TType.STRING:
+          self.log = iprot.readString();
+        else:
+          iprot.skip(ftype)
+      else:
+        iprot.skip(ftype)
+      iprot.readFieldEnd()
+    iprot.readStructEnd()
+
+  def write(self, oprot):
+    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
+      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
+      return
+    oprot.writeStructBegin('TGetLogResp')
+    if self.status is not None:
+      oprot.writeFieldBegin('status', TType.STRUCT, 1)
+      self.status.write(oprot)
+      oprot.writeFieldEnd()
+    if self.log is not None:
+      oprot.writeFieldBegin('log', TType.STRING, 2)
+      oprot.writeString(self.log)
+      oprot.writeFieldEnd()
+    oprot.writeFieldStop()
+    oprot.writeStructEnd()
+
+  def validate(self):
+    if self.status is None:
+      raise TProtocol.TProtocolException(message='Required field status is unset!')
+    if self.log is None:
+      raise TProtocol.TProtocolException(message='Required field log is unset!')
+    return
+
+
+  def __repr__(self):
+    L = ['%s=%r' % (key, value)
+      for key, value in self.__dict__.iteritems()]
+    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+  def __eq__(self, other):
+    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+  def __ne__(self, other):
+    return not (self == other)
diff --git a/src/service/src/gen/thrift/gen-rb/t_c_l_i_service.rb b/src/service/src/gen/thrift/gen-rb/t_c_l_i_service.rb
index 2455e3b..346fd57 100644
--- a/src/service/src/gen/thrift/gen-rb/t_c_l_i_service.rb
+++ b/src/service/src/gen/thrift/gen-rb/t_c_l_i_service.rb
@@ -251,6 +251,21 @@ module TCLIService
       raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'FetchResults failed: unknown result')
     end
 
+    def GetLog(req)
+      send_GetLog(req)
+      return recv_GetLog()
+    end
+
+    def send_GetLog(req)
+      send_message('GetLog', GetLog_args, :req => req)
+    end
+
+    def recv_GetLog()
+      result = receive_message(GetLog_result)
+      return result.success unless result.success.nil?
+      raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'GetLog failed: unknown result')
+    end
+
   end
 
   class Processor
@@ -368,6 +383,13 @@ module TCLIService
       write_result(result, oprot, 'FetchResults', seqid)
     end
 
+    def process_GetLog(seqid, iprot, oprot)
+      args = read_args(iprot, GetLog_args)
+      result = GetLog_result.new()
+      result.success = @handler.GetLog(args.req)
+      write_result(result, oprot, 'GetLog', seqid)
+    end
+
   end
 
   # HELPER FUNCTIONS AND STRUCTURES
@@ -884,5 +906,37 @@ module TCLIService
     ::Thrift::Struct.generate_accessors self
   end
 
+  class GetLog_args
+    include ::Thrift::Struct, ::Thrift::Struct_Union
+    REQ = 1
+
+    FIELDS = {
+      REQ => {:type => ::Thrift::Types::STRUCT, :name => 'req', :class => ::TGetLogReq}
+    }
+
+    def struct_fields; FIELDS; end
+
+    def validate
+    end
+
+    ::Thrift::Struct.generate_accessors self
+  end
+
+  class GetLog_result
+    include ::Thrift::Struct, ::Thrift::Struct_Union
+    SUCCESS = 0
+
+    FIELDS = {
+      SUCCESS => {:type => ::Thrift::Types::STRUCT, :name => 'success', :class => ::TGetLogResp}
+    }
+
+    def struct_fields; FIELDS; end
+
+    def validate
+    end
+
+    ::Thrift::Struct.generate_accessors self
+  end
+
 end
 
diff --git a/src/service/src/gen/thrift/gen-rb/t_c_l_i_service_types.rb b/src/service/src/gen/thrift/gen-rb/t_c_l_i_service_types.rb
index 5336945..7e7fcb0 100644
--- a/src/service/src/gen/thrift/gen-rb/t_c_l_i_service_types.rb
+++ b/src/service/src/gen/thrift/gen-rb/t_c_l_i_service_types.rb
@@ -1407,3 +1407,40 @@ class TFetchResultsResp
   ::Thrift::Struct.generate_accessors self
 end
 
+class TGetLogReq
+  include ::Thrift::Struct, ::Thrift::Struct_Union
+  OPERATIONHANDLE = 1
+
+  FIELDS = {
+    OPERATIONHANDLE => {:type => ::Thrift::Types::STRUCT, :name => 'operationHandle', :class => ::TOperationHandle}
+  }
+
+  def struct_fields; FIELDS; end
+
+  def validate
+    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field operationHandle is unset!') unless @operationHandle
+  end
+
+  ::Thrift::Struct.generate_accessors self
+end
+
+class TGetLogResp
+  include ::Thrift::Struct, ::Thrift::Struct_Union
+  STATUS = 1
+  LOG = 2
+
+  FIELDS = {
+    STATUS => {:type => ::Thrift::Types::STRUCT, :name => 'status', :class => ::TStatus},
+    LOG => {:type => ::Thrift::Types::STRING, :name => 'log'}
+  }
+
+  def struct_fields; FIELDS; end
+
+  def validate
+    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
+    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field log is unset!') unless @log
+  end
+
+  ::Thrift::Struct.generate_accessors self
+end
+
diff --git a/src/service/src/java/org/apache/hive/service/cli/CLIService.java b/src/service/src/java/org/apache/hive/service/cli/CLIService.java
index 2d474cb..e8e7e88 100644
--- a/src/service/src/java/org/apache/hive/service/cli/CLIService.java
+++ b/src/service/src/java/org/apache/hive/service/cli/CLIService.java
@@ -35,6 +35,7 @@ import org.apache.hadoop.hive.shims.ShimLoader;
 import org.apache.hive.service.CompositeService;
 import org.apache.hive.service.ServiceException;
 import org.apache.hive.service.auth.HiveAuthFactory;
+import org.apache.hive.service.cli.log.OperationLog;
 import org.apache.hive.service.cli.session.HiveSession;
 import org.apache.hive.service.cli.session.SessionManager;
 
@@ -103,7 +104,7 @@ public class CLIService extends CompositeService implements ICLIService {
   public SessionHandle openSession(String username, String password, Map<String, String> configuration)
       throws HiveSQLException {
     SessionHandle sessionHandle = sessionManager.openSession(username, password, configuration, false, null);
-    LOG.info(sessionHandle + ": openSession()");
+    LOG.info(sessionHandle  + ": openSession()");
     sessionManager.clearThreadLocals();
     return sessionHandle;
   }
@@ -116,7 +117,7 @@ public class CLIService extends CompositeService implements ICLIService {
        String delegationToken) throws HiveSQLException {
     SessionHandle sessionHandle = sessionManager.openSession(username, password, configuration,
           true, delegationToken);
-    LOG.info(sessionHandle + ": openSession()");
+    LOG.info(sessionHandle  + ": openSessionWithImpersonation()");
     sessionManager.clearThreadLocals();
     return sessionHandle;
   }
@@ -128,7 +129,7 @@ public class CLIService extends CompositeService implements ICLIService {
   public void closeSession(SessionHandle sessionHandle)
       throws HiveSQLException {
     sessionManager.closeSession(sessionHandle);
-    LOG.info(sessionHandle + ": closeSession()");
+    LOG.info(sessionHandle  + ": closeSession()");
     sessionManager.clearThreadLocals();
   }
 
@@ -139,7 +140,7 @@ public class CLIService extends CompositeService implements ICLIService {
   public GetInfoValue getInfo(SessionHandle sessionHandle, GetInfoType getInfoType)
       throws HiveSQLException {
     GetInfoValue infoValue = sessionManager.getSession(sessionHandle).getInfo(getInfoType);
-    LOG.info(sessionHandle + ": getInfo()");
+    LOG.info(sessionHandle  + ": getInfo()");
     sessionManager.clearThreadLocals();
     return infoValue;
   }
@@ -152,7 +153,7 @@ public class CLIService extends CompositeService implements ICLIService {
       throws HiveSQLException {
     OperationHandle opHandle = sessionManager.getSession(sessionHandle)
         .executeStatement(statement, confOverlay);
-    LOG.info(sessionHandle + ": executeStatement()");
+    LOG.info(sessionHandle  + ": executeStatement()");
     sessionManager.clearThreadLocals();
     return opHandle;
   }
@@ -164,7 +165,7 @@ public class CLIService extends CompositeService implements ICLIService {
   public OperationHandle getTypeInfo(SessionHandle sessionHandle)
       throws HiveSQLException {
     OperationHandle opHandle = sessionManager.getSession(sessionHandle).getTypeInfo();
-    LOG.info(sessionHandle + ": getTypeInfo()");
+    LOG.info(sessionHandle  + ": getTypeInfo()");
     sessionManager.clearThreadLocals();
     return opHandle;
   }
@@ -176,7 +177,7 @@ public class CLIService extends CompositeService implements ICLIService {
   public OperationHandle getCatalogs(SessionHandle sessionHandle)
       throws HiveSQLException {
     OperationHandle opHandle = sessionManager.getSession(sessionHandle).getCatalogs();
-    LOG.info(sessionHandle + ": getCatalogs()");
+    LOG.info(sessionHandle  + ": getCatalogs()");
     sessionManager.clearThreadLocals();
     return opHandle;
   }
@@ -190,7 +191,7 @@ public class CLIService extends CompositeService implements ICLIService {
       throws HiveSQLException {
     OperationHandle opHandle = sessionManager.getSession(sessionHandle)
         .getSchemas(catalogName, schemaName);
-    LOG.info(sessionHandle + ": getSchemas()");
+    LOG.info(sessionHandle  + ": getSchemas()");
     sessionManager.clearThreadLocals();
     return opHandle;
   }
@@ -204,7 +205,7 @@ public class CLIService extends CompositeService implements ICLIService {
       throws HiveSQLException {
     OperationHandle opHandle = sessionManager
         .getSession(sessionHandle).getTables(catalogName, schemaName, tableName, tableTypes);
-    LOG.info(sessionHandle + ": getTables()");
+    LOG.info(sessionHandle  + ": getTables()");
     sessionManager.clearThreadLocals();
     return opHandle;
   }
@@ -216,7 +217,7 @@ public class CLIService extends CompositeService implements ICLIService {
   public OperationHandle getTableTypes(SessionHandle sessionHandle)
       throws HiveSQLException {
     OperationHandle opHandle = sessionManager.getSession(sessionHandle).getTableTypes();
-    LOG.info(sessionHandle + ": getTableTypes()");
+    LOG.info(sessionHandle  + ": getTableTypes()");
     sessionManager.clearThreadLocals();
     return opHandle;
   }
@@ -230,7 +231,7 @@ public class CLIService extends CompositeService implements ICLIService {
       throws HiveSQLException {
     OperationHandle opHandle = sessionManager.getSession(sessionHandle)
         .getColumns(catalogName, schemaName, tableName, columnName);
-    LOG.info(sessionHandle + ": getColumns()");
+    LOG.info(sessionHandle  + ": getColumns()");
     sessionManager.clearThreadLocals();
     return opHandle;
   }
@@ -244,7 +245,7 @@ public class CLIService extends CompositeService implements ICLIService {
       throws HiveSQLException {
     OperationHandle opHandle = sessionManager.getSession(sessionHandle)
         .getFunctions(catalogName, schemaName, functionName);
-    LOG.info(sessionHandle + ": getFunctions()");
+    LOG.info(sessionHandle  + ": getFunctions()");
     sessionManager.clearThreadLocals();
     return opHandle;
   }
@@ -255,9 +256,11 @@ public class CLIService extends CompositeService implements ICLIService {
   @Override
   public OperationState getOperationStatus(OperationHandle opHandle)
       throws HiveSQLException {
+    startLogCapture(opHandle);
     OperationState opState = sessionManager.getOperationManager().getOperationState(opHandle);
     LOG.info(opHandle + ": getOperationStatus()");
     sessionManager.clearThreadLocals();
+    stopLogCapture();
     return opState;
   }
 
@@ -267,10 +270,12 @@ public class CLIService extends CompositeService implements ICLIService {
   @Override
   public void cancelOperation(OperationHandle opHandle)
       throws HiveSQLException {
+    startLogCapture(opHandle);
     sessionManager.getOperationManager().getOperation(opHandle).
         getParentSession().cancelOperation(opHandle);
-    LOG.info(opHandle + ": cancelOperation()");
+    LOG.info(opHandle  + ": cancelOperation()");
     sessionManager.clearThreadLocals();
+    stopLogCapture();
     }
 
   /* (non-Javadoc)
@@ -279,10 +284,12 @@ public class CLIService extends CompositeService implements ICLIService {
   @Override
   public void closeOperation(OperationHandle opHandle)
       throws HiveSQLException {
+    startLogCapture(opHandle);
     sessionManager.getOperationManager().getOperation(opHandle).
         getParentSession().closeOperation(opHandle);
-    LOG.info(opHandle + ": closeOperation");
+    LOG.info(opHandle  + ": closeOperation");
     sessionManager.clearThreadLocals();
+    stopLogCapture();
   }
 
   /* (non-Javadoc)
@@ -291,10 +298,12 @@ public class CLIService extends CompositeService implements ICLIService {
   @Override
   public TableSchema getResultSetMetadata(OperationHandle opHandle)
       throws HiveSQLException {
+    startLogCapture(opHandle);
     TableSchema tableSchema = sessionManager.getOperationManager().getOperation(opHandle).
         getParentSession().getResultSetMetadata(opHandle);
-    LOG.info(opHandle + ": getResultSetMetadata()");
+    LOG.info(opHandle  + ": getResultSetMetadata()");
     sessionManager.clearThreadLocals();
+    stopLogCapture();
     return tableSchema;
   }
 
@@ -304,10 +313,12 @@ public class CLIService extends CompositeService implements ICLIService {
   @Override
   public RowSet fetchResults(OperationHandle opHandle, FetchOrientation orientation, long maxRows)
       throws HiveSQLException {
+    startLogCapture(opHandle);
     RowSet rowSet = sessionManager.getOperationManager().getOperation(opHandle).
         getParentSession().fetchResults(opHandle, orientation, maxRows);
-    LOG.info(opHandle + ": fetchResults()");
+    LOG.info(opHandle  + ": fetchResults()");
     sessionManager.clearThreadLocals();
+    stopLogCapture();
     return rowSet;
   }
 
@@ -317,10 +328,12 @@ public class CLIService extends CompositeService implements ICLIService {
   @Override
   public RowSet fetchResults(OperationHandle opHandle)
       throws HiveSQLException {
+    startLogCapture(opHandle);
     RowSet rowSet = sessionManager.getOperationManager().getOperation(opHandle).
         getParentSession().fetchResults(opHandle);
-    LOG.info(opHandle + ": fetchResults()");
+    LOG.info(opHandle  + ": fetchResults()");
     sessionManager.clearThreadLocals();
+    stopLogCapture();
     return rowSet;
   }
 
@@ -364,4 +377,25 @@ public class CLIService extends CompositeService implements ICLIService {
       }
     }
   }
+
+  /* (non-Javadoc)
+   * @see org.apache.hive.service.cli.ICLIService#getLog(org.apache.hive.service.cli.OperationHandle)
+   */
+   @Override
+   public String getLog(OperationHandle opHandle)
+      throws HiveSQLException {
+     OperationLog log = sessionManager.getLogManager().getOperationLogByOperation(opHandle, false);
+     LOG.info(opHandle  + ": getLog()");
+     sessionManager.clearThreadLocals();
+     return log.readOperationLog();
+   }
+
+  private void startLogCapture(OperationHandle operationHandle) throws HiveSQLException {
+    sessionManager.getLogManager().unregisterCurrentThread();
+    sessionManager.getLogManager().registerCurrentThread(operationHandle);
+  }
+
+  private void stopLogCapture() {
+    sessionManager.getLogManager().unregisterCurrentThread();
+  }
 }
diff --git a/src/service/src/java/org/apache/hive/service/cli/CLIServiceClient.java b/src/service/src/java/org/apache/hive/service/cli/CLIServiceClient.java
index fe49025..6d25782 100644
--- a/src/service/src/java/org/apache/hive/service/cli/CLIServiceClient.java
+++ b/src/service/src/java/org/apache/hive/service/cli/CLIServiceClient.java
@@ -149,4 +149,7 @@ public abstract class CLIServiceClient implements ICLIService {
     return fetchResults(opHandle, FetchOrientation.FETCH_NEXT, 1000);
   }
 
+  @Override
+  public abstract String getLog(OperationHandle opHandle) throws HiveSQLException;
+
 }
diff --git a/src/service/src/java/org/apache/hive/service/cli/EmbeddedCLIServiceClient.java b/src/service/src/java/org/apache/hive/service/cli/EmbeddedCLIServiceClient.java
index 38d64c8..09112c1 100644
--- a/src/service/src/java/org/apache/hive/service/cli/EmbeddedCLIServiceClient.java
+++ b/src/service/src/java/org/apache/hive/service/cli/EmbeddedCLIServiceClient.java
@@ -176,4 +176,9 @@ public class EmbeddedCLIServiceClient extends CLIServiceClient {
     return cliService.fetchResults(opHandle, orientation, maxRows);
   }
 
+  @Override
+  public String getLog(OperationHandle opHandle)
+      throws HiveSQLException {
+    return cliService.getLog(opHandle);
+  }
 }
diff --git a/src/service/src/java/org/apache/hive/service/cli/ICLIService.java b/src/service/src/java/org/apache/hive/service/cli/ICLIService.java
index 7e863b5..f3fd2c2 100644
--- a/src/service/src/java/org/apache/hive/service/cli/ICLIService.java
+++ b/src/service/src/java/org/apache/hive/service/cli/ICLIService.java
@@ -20,9 +20,6 @@ package org.apache.hive.service.cli;
 import java.util.List;
 import java.util.Map;
 
-
-
-
 public interface ICLIService {
 
   public abstract SessionHandle openSession(String username, String password,
@@ -87,4 +84,6 @@ public interface ICLIService {
   public abstract RowSet fetchResults(OperationHandle opHandle)
       throws HiveSQLException;
 
+  public abstract String getLog(OperationHandle opHandle)
+      throws HiveSQLException;
 }
diff --git a/src/service/src/java/org/apache/hive/service/cli/log/LinkedStringBuffer.java b/src/service/src/java/org/apache/hive/service/cli/log/LinkedStringBuffer.java
new file mode 100644
index 0000000..c4a5106
--- /dev/null
+++ b/src/service/src/java/org/apache/hive/service/cli/log/LinkedStringBuffer.java
@@ -0,0 +1,80 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hive.service.cli.log;
+
+import java.util.LinkedList;
+
+/**
+ * A linked string buffer with a capacity limit.
+ */
+public class LinkedStringBuffer {
+
+  private final LinkedList<String> list;
+  private final long capacity;
+  private int size;
+
+  /**
+   * Create a buffer with the specified capacity on the number of characters.
+   */
+  public LinkedStringBuffer(long capacity) {
+    this.capacity = capacity;
+    list = new LinkedList<String>();
+  }
+
+  /**
+   * @return Size (number of characters) in the buffer
+   */
+  public synchronized long size() {
+    return size;
+  }
+
+  /**
+   * Write to the buffer, which will remove previously written strings if
+   * we don't fit in capacity.
+   */
+  public synchronized void write(String data) {
+    list.add(data);
+    size += data.length();
+
+    // Trim from the front
+    while (size > capacity) {
+      String evicted = list.remove(0);
+      size -= evicted.length();
+    }
+  }
+
+  /**
+   * @return All the data in the buffer.
+   */
+  public synchronized String read() {
+    StringBuilder sb = new StringBuilder(size);
+    for (String s : list) {
+      sb.append(s);
+    }
+    return sb.toString();
+  }
+
+  /**
+   * Remove all stored data.
+   */
+  public synchronized void clear() {
+    list.clear();
+    size = 0;
+  }
+}
diff --git a/src/service/src/java/org/apache/hive/service/cli/log/LogDivertAppender.java b/src/service/src/java/org/apache/hive/service/cli/log/LogDivertAppender.java
new file mode 100644
index 0000000..399d280
--- /dev/null
+++ b/src/service/src/java/org/apache/hive/service/cli/log/LogDivertAppender.java
@@ -0,0 +1,91 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hive.service.cli.log;
+
+import java.io.CharArrayWriter;
+
+import org.apache.log4j.Layout;
+import org.apache.log4j.Logger;
+import org.apache.log4j.WriterAppender;
+import org.apache.log4j.spi.Filter;
+import org.apache.log4j.spi.LoggingEvent;
+
+/**
+ * An Appender to divert logs from individual threads to the LogObject they belong to.
+ */
+public class LogDivertAppender extends WriterAppender {
+  private static final Logger LOG = Logger.getLogger(LogDivertAppender.class.getName());
+  private final LogManager logManager;
+
+  /**
+   * A log filter that exclude messages coming from the logger with the given name.
+   * We apply this filter on the Loggers used by the log diversion stuff, so that
+   * they don't generate more logs for themselves when they process logs.
+   */
+  private class NameExclusionFilter extends Filter {
+    private String excludeLoggerName = null;
+
+    public NameExclusionFilter(String excludeLoggerName) {
+      super();
+      this.excludeLoggerName = excludeLoggerName;
+    }
+
+    @Override
+    public int decide(LoggingEvent ev) {
+      if (ev.getLoggerName().equals(excludeLoggerName)) {
+        return Filter.DENY;
+      }
+      return Filter.NEUTRAL;
+    }
+  }
+
+  /** This is where the log message will go to */
+  private final CharArrayWriter writer = new CharArrayWriter();
+
+  public LogDivertAppender(Layout layout, LogManager logManager) {
+    super();
+    this.setLayout(layout);
+    this.setWriter(writer);
+    this.setName("LogDivertAppender");
+    this.logManager = logManager;
+
+    // Filter out messages coming from log processing classes, or we'll run an infinite loop.
+    this.addFilter(new NameExclusionFilter(LOG.getName()));
+    this.addFilter(new NameExclusionFilter(OperationLog.class.getName()));
+  }
+
+  /**
+   * Overrides WriterAppender.subAppend(), which does the real logging.
+   * No need to worry about concurrency since log4j calls this synchronously.
+   */
+  @Override
+  protected void subAppend(LoggingEvent event) {
+    super.subAppend(event);
+    // That should've gone into our writer. Notify the LogContext.
+    String logOutput = writer.toString();
+    writer.reset();
+
+    OperationLog log = logManager.getOperationLogByThreadName(event.getThreadName());
+    if (log == null) {
+      LOG.debug(" ---+++=== Dropped log event from thread " + event.getThreadName());
+      return;
+    }
+    log.writeOperationLog(logOutput);
+  }
+}
diff --git a/src/service/src/java/org/apache/hive/service/cli/log/LogManager.java b/src/service/src/java/org/apache/hive/service/cli/log/LogManager.java
new file mode 100644
index 0000000..8ed7541
--- /dev/null
+++ b/src/service/src/java/org/apache/hive/service/cli/log/LogManager.java
@@ -0,0 +1,184 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hive.service.cli.log;
+
+
+import java.util.Enumeration;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+import org.apache.hadoop.hive.conf.HiveConf;
+import org.apache.hive.service.AbstractService;
+import org.apache.hive.service.cli.HiveSQLException;
+import org.apache.hive.service.cli.OperationHandle;
+import org.apache.hive.service.cli.session.SessionManager;
+import org.apache.log4j.Appender;
+import org.apache.log4j.ConsoleAppender;
+import org.apache.log4j.Layout;
+import org.apache.log4j.Logger;
+import org.apache.log4j.PatternLayout;
+
+/**
+ * LogManager - LogManager is responsible for managing the lifecycle of in memory operation logs for HS2.
+ * Each log object is maintained as a rolling log whose size can't exceed 1MB.
+ * LogManager tracks the log objects by operation handle as well as by the thread whose output will
+ * be redirected to these log objects.
+ */
+public class LogManager extends AbstractService {
+  private HiveConf hiveConf;
+
+  private final Map<OperationHandle, OperationLog> OperationLogByOperation =
+      new ConcurrentHashMap<OperationHandle, OperationLog> ();
+  private final Map<String, OperationLog> OperationLogByThreadName =
+      new ConcurrentHashMap<String, OperationLog> ();
+
+  private boolean isOperationLogCaptureIntialized = false;
+
+  private static final String DEFAULT_LAYOUT_PATTERN = "%d{yy/MM/dd HH:mm:ss} %p %c{2}: %m%n";
+
+  private static Logger LOG = Logger.getLogger(LogManager.class.getName());
+  private SessionManager sessionManager;
+
+  public LogManager() {
+    super("LogManager");
+  }
+
+  public void setSessionManager(SessionManager sessionManager) {
+    this.sessionManager = sessionManager;
+  }
+
+  public SessionManager getSessionManager() {
+    return sessionManager;
+  }
+
+  public void initOperationLogCapture() {
+    if (isOperationLogCaptureIntialized) {
+      return;
+    }
+
+    // There should be a ConsoleAppender. Copy its Layout.
+    Logger root = Logger.getRootLogger();
+    Layout layout = null;
+
+    Enumeration<?> appenders = root.getAllAppenders();
+    while (appenders.hasMoreElements()) {
+      Appender ap = (Appender) appenders.nextElement();
+      if (ap.getClass().equals(ConsoleAppender.class)) {
+        layout = ap.getLayout();
+        break;
+      }
+    }
+
+    if (layout == null) {
+      layout = new PatternLayout(DEFAULT_LAYOUT_PATTERN);
+      LOG.info("Cannot find a Layout from a ConsoleAppender. Using default Layout pattern.");
+    }
+
+    // Register another Appender (with the same layout) that talks to us.
+    Appender ap = new LogDivertAppender(layout, this);
+    root.addAppender(ap);
+
+    isOperationLogCaptureIntialized = true;
+  }
+
+  public OperationLog createNewOperationLog(OperationHandle operationHandle, String name) {
+    int size = HiveConf.getIntVar(hiveConf, HiveConf.ConfVars.HIVE_SERVER2_IN_MEM_LOG_SIZE);
+    LOG.info("Operation log size: " + size);
+    OperationLog OperationLog = new OperationLog(name, size);
+    OperationLogByOperation.put(operationHandle, OperationLog);
+    return OperationLog;
+  }
+
+  public boolean destroyOperationLog(OperationHandle operationHandle) {
+    OperationLog OperationLog = OperationLogByOperation.remove(operationHandle);
+    if (OperationLog == null) {
+      LOG.debug("No OperationLog found for operation: " + operationHandle.hashCode());
+      return false;
+    }
+    return true;
+  }
+
+  public void registerCurrentThread(OperationHandle operationHandle) throws HiveSQLException {
+    String threadName = Thread.currentThread().getName();
+
+    OperationLog OperationLog = getOperationLogByOperation(operationHandle, true);
+
+    if (OperationLogByThreadName.containsKey(threadName)) {
+      LOG.debug("Thread: " + threadName + " is already registered.");
+    }
+    OperationLogByThreadName.put(threadName, OperationLog);
+  }
+
+  public void registerCurrentThread(OperationLog OperationLog) {
+    String threadName = Thread.currentThread().getName();
+    OperationLogByThreadName.put(threadName, OperationLog);
+  }
+
+  public boolean unregisterCurrentThread() {
+    String threadName = Thread.currentThread().getName();
+    OperationLog OperationLog = OperationLogByThreadName.remove(threadName);
+    if (OperationLog == null) {
+      LOG.debug("Failed to unregister thread " + threadName + ": OperationLog object is currently "
+          + "not regsitered");
+      return false;
+    }
+    return true;
+  }
+
+  public OperationLog getOperationLogByThreadName(String threadName) {
+    OperationLog OperationLog = OperationLogByThreadName.get(threadName);
+    if (OperationLog == null) {
+      LOG.debug("Operation log assocaited with thread: " + threadName + " couldn't be found.");
+    }
+    return OperationLog;
+  }
+
+  public OperationLog getOperationLogByOperation(OperationHandle operationHandle,
+    boolean createIfAbsent) throws HiveSQLException {
+    OperationLog operationLog = OperationLogByOperation.get(operationHandle);
+    if (operationLog == null && createIfAbsent) {
+      operationLog = createNewOperationLog(operationHandle, operationHandle.toString());
+    } else if (operationLog == null) {
+      throw new HiveSQLException("Couldn't find log associated with operation handle: " +
+        operationHandle.toString());
+    }
+    return operationLog;
+  }
+
+  @Override
+  public synchronized void init(HiveConf hiveConf) {
+    this.hiveConf = hiveConf;
+    super.init(hiveConf);
+    if (HiveConf.getBoolVar(hiveConf, HiveConf.ConfVars.HIVE_SERVER2_IN_MEM_LOGGING)) {
+      initOperationLogCapture();
+    } else {
+      LOG.info("Opeation level logging is turned off");
+    }
+  }
+
+  @Override
+  public synchronized void start() {
+    super.start();
+  }
+
+  @Override
+  public synchronized void stop() {
+    super.stop();
+  }
+}
diff --git a/src/service/src/java/org/apache/hive/service/cli/log/OperationLog.java b/src/service/src/java/org/apache/hive/service/cli/log/OperationLog.java
new file mode 100644
index 0000000..d2351a7
--- /dev/null
+++ b/src/service/src/java/org/apache/hive/service/cli/log/OperationLog.java
@@ -0,0 +1,92 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hive.service.cli.log;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+import org.apache.log4j.Logger;
+
+import com.google.common.base.Charsets;
+
+public class OperationLog {
+
+  private static final String HIVE_ENCODING = Charsets.UTF_8.name();
+
+  // This OperationLogger's name is added to an exclusion list in OperationLogDivertAppender
+  private static Logger LOG = Logger.getLogger(OperationLog.class.getName());
+
+  private final String operationLogName;
+  private final LinkedStringBuffer operationLogBuffer;
+  private final long creationTime;
+
+  OperationLog(String name, int size) {
+    this.operationLogName = name;
+    this.operationLogBuffer = new LinkedStringBuffer(size);
+    this.creationTime = System.currentTimeMillis();
+  }
+
+  public void writeOperationLog(String OperationLogMessage) {
+    operationLogBuffer.write(OperationLogMessage);
+  }
+
+  public String readOperationLog() {
+    return operationLogBuffer.read();
+  }
+
+  public void resetOperationLog() {
+    operationLogBuffer.clear();
+  }
+
+  /**
+   * The OperationLogOutputStream helps translate a OperationLog to an OutputStream.
+   */
+  private static class OperationLogOutputStream extends OutputStream {
+    private final LinkedStringBuffer backingStore;
+
+    public OperationLogOutputStream(LinkedStringBuffer operationLogBuffer) {
+      super();
+      backingStore = operationLogBuffer;
+    }
+
+    @Override
+    public void write(byte[] b) throws IOException {
+      backingStore.write(new String(b, HIVE_ENCODING));
+    }
+
+    @Override
+    public void write(byte[] b, int off, int len) throws IOException {
+      backingStore.write(new String(b, off, len, HIVE_ENCODING));
+    }
+
+    @Override
+    public void write(int b) throws IOException {
+      byte[] buf = { (byte) b };
+      this.write(buf);
+    }
+  }
+
+  public OutputStream getOutputStream() {
+    return new OperationLogOutputStream(operationLogBuffer);
+  }
+
+  public String getName() {
+    return operationLogName;
+  }
+}
\ No newline at end of file
diff --git a/src/service/src/java/org/apache/hive/service/cli/operation/AsyncExecStmtOperation.java b/src/service/src/java/org/apache/hive/service/cli/operation/AsyncExecStmtOperation.java
index 3890479..12adf50 100644
--- a/src/service/src/java/org/apache/hive/service/cli/operation/AsyncExecStmtOperation.java
+++ b/src/service/src/java/org/apache/hive/service/cli/operation/AsyncExecStmtOperation.java
@@ -13,6 +13,7 @@ import org.apache.hadoop.hive.conf.HiveConf;
 import org.apache.hadoop.hive.ql.session.SessionState;
 import org.apache.hive.service.cli.FetchOrientation;
 import org.apache.hive.service.cli.HiveSQLException;
+import org.apache.hive.service.cli.OperationHandle;
 import org.apache.hive.service.cli.OperationState;
 import org.apache.hive.service.cli.RowSet;
 import org.apache.hive.service.cli.TableSchema;
@@ -38,13 +39,25 @@ public class AsyncExecStmtOperation extends ExecuteStatementOperation {
     return newExecOP;
   }
 
+  private void startLogCapture(HiveSession parentSession, OperationHandle opHandle) throws HiveSQLException {
+    parentSession.getSessionManager().getLogManager().registerCurrentThread(opHandle);
+  }
+
+  private void stopLogCapture(HiveSession parentSession) {
+    parentSession.getSessionManager().getLogManager().unregisterCurrentThread();
+  }
+
   @Override
   public void run() throws HiveSQLException {
     prepare();
     final ExecuteStatementOperation currExec = execOP;
+    final HiveSession parentSession = getParentSession();
+    final OperationHandle parentHandle = getHandle();
     execFuture = opExecutor.submit(new Callable<String>() {
       public String  call() throws HiveSQLException {
+        startLogCapture(parentSession, parentHandle);
         currExec.run();
+        stopLogCapture(parentSession);
         return null;
       }
     });
@@ -53,13 +66,17 @@ public class AsyncExecStmtOperation extends ExecuteStatementOperation {
   @Override
   public void prepare() throws HiveSQLException {
     final ExecuteStatementOperation currExec = execOP;
+    final HiveSession parentSession = getParentSession();
+    final OperationHandle parentHandle = getHandle();
     execFuture = opExecutor.submit(new Callable<String>() {
       public String  call() throws HiveSQLException {
         // Clone the current configuration for an async query. we don't want the
         // query to see the config changes after the query starts to execute
+        startLogCapture(parentSession, parentHandle);
         HiveConf queryConf = new HiveConf(getParentSession().getHiveConf());
         SessionState.start(currExec.getParentSession().getSessionState());
         currExec.prepare(queryConf);
+        stopLogCapture(parentSession);
         return null;
       }
     });
@@ -72,9 +89,13 @@ public class AsyncExecStmtOperation extends ExecuteStatementOperation {
     // wait for the async statement to finish
     waitForCompletion(execFuture);
     final ExecuteStatementOperation currExec = execOP;
+    final HiveSession parentSession = getParentSession();
+    final OperationHandle parentHandle = getHandle();
     Future<String> opFuture = opExecutor.submit(new Callable<String>() {
       public String  call() throws HiveSQLException {
+        startLogCapture(parentSession, parentHandle);
         currExec.close();
+        stopLogCapture(parentSession);
         return null;
       }
     });
@@ -85,9 +106,13 @@ public class AsyncExecStmtOperation extends ExecuteStatementOperation {
   @Override
   public void cancel() throws HiveSQLException {
     final ExecuteStatementOperation currExec = execOP;
+    final HiveSession parentSession = getParentSession();
+    final OperationHandle parentHandle = getHandle();
     Future<String> opFuture = opExecutor.submit(new Callable<String>() {
       public String  call() throws HiveSQLException {
+        startLogCapture(parentSession, parentHandle);
         currExec.cancel();
+        stopLogCapture(parentSession);
         return null;
       }
     });
@@ -105,9 +130,14 @@ public class AsyncExecStmtOperation extends ExecuteStatementOperation {
           throws HiveSQLException {
     checkExecutionStatus();
     final ExecuteStatementOperation currExec = execOP;
+    final HiveSession parentSession = getParentSession();
+    final OperationHandle parentHandle = getHandle();
     Future<RowSet> opFuture = opExecutor.submit(new Callable<RowSet>() {
       public RowSet call() throws HiveSQLException {
-        return currExec.getNextRowSet(orientation, maxRows);
+        startLogCapture(parentSession, parentHandle);
+        RowSet rowSet = currExec.getNextRowSet(orientation, maxRows);
+        stopLogCapture(parentSession);
+        return rowSet;
       }
     });
     return waitForCompletion(opFuture);
diff --git a/src/service/src/java/org/apache/hive/service/cli/operation/OperationManager.java b/src/service/src/java/org/apache/hive/service/cli/operation/OperationManager.java
index e5c763d..21f6e40 100644
--- a/src/service/src/java/org/apache/hive/service/cli/operation/OperationManager.java
+++ b/src/service/src/java/org/apache/hive/service/cli/operation/OperationManager.java
@@ -31,6 +31,7 @@ import org.apache.hive.service.cli.OperationState;
 import org.apache.hive.service.cli.RowSet;
 import org.apache.hive.service.cli.TableSchema;
 import org.apache.hive.service.cli.session.HiveSession;
+import org.apache.hive.service.cli.session.SessionManager;
 
 /**
  * OperationManager.
@@ -41,6 +42,7 @@ public class OperationManager extends AbstractService {
   private HiveConf hiveConf;
   private final Map<OperationHandle, Operation> handleToOperation =
       new HashMap<OperationHandle, Operation>();
+  private SessionManager sessionManager;
 
   public OperationManager() {
     super("OperationManager");
@@ -65,6 +67,13 @@ public class OperationManager extends AbstractService {
     super.stop();
   }
 
+  public void setSessionManager(SessionManager sessionManager) {
+    this.sessionManager = sessionManager;
+  }
+
+  public SessionManager getSessionManager() {
+    return sessionManager;
+  }
   public ExecuteStatementOperation newExecuteStatementOperation(HiveSession parentSession,
       String statement, Map<String, String> confOverlay) {
     ExecuteStatementOperation executeStatementOperation = ExecuteStatementOperation
@@ -168,5 +177,5 @@ public class OperationManager extends AbstractService {
       FetchOrientation orientation, long maxRows)
       throws HiveSQLException {
     return getOperation(opHandle).getNextRowSet(orientation, maxRows);
-  }
+ }
 }
diff --git a/src/service/src/java/org/apache/hive/service/cli/session/HiveSession.java b/src/service/src/java/org/apache/hive/service/cli/session/HiveSession.java
index d4651e0..bc6e58c 100644
--- a/src/service/src/java/org/apache/hive/service/cli/session/HiveSession.java
+++ b/src/service/src/java/org/apache/hive/service/cli/session/HiveSession.java
@@ -32,6 +32,7 @@ import org.apache.hive.service.cli.OperationHandle;
 import org.apache.hive.service.cli.RowSet;
 import org.apache.hive.service.cli.SessionHandle;
 import org.apache.hive.service.cli.TableSchema;
+import org.apache.hive.service.cli.log.LogManager;
 import org.apache.hive.service.cli.operation.OperationManager;
 
 public interface HiveSession {
@@ -41,6 +42,8 @@ public interface HiveSession {
    */
   public void setSessionManager(SessionManager sessionManager);
 
+  public SessionManager getSessionManager();
+
   /**
    * Set operation manager for the session
    * @param operationManager
@@ -168,4 +171,8 @@ public interface HiveSession {
   public String getUserName();
 
   public void setUserName(String userName);
+
+  public void setLogManager(LogManager logManager);
+
+  public LogManager getLogManager();
 }
diff --git a/src/service/src/java/org/apache/hive/service/cli/session/HiveSessionImpl.java b/src/service/src/java/org/apache/hive/service/cli/session/HiveSessionImpl.java
index dda6ccd..9668fe6 100644
--- a/src/service/src/java/org/apache/hive/service/cli/session/HiveSessionImpl.java
+++ b/src/service/src/java/org/apache/hive/service/cli/session/HiveSessionImpl.java
@@ -21,7 +21,6 @@ package org.apache.hive.service.cli.session;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.Map.Entry;
 
 import org.apache.hadoop.hive.conf.HiveConf;
 import org.apache.hadoop.hive.metastore.HiveMetaStoreClient;
@@ -36,6 +35,7 @@ import org.apache.hive.service.cli.OperationHandle;
 import org.apache.hive.service.cli.RowSet;
 import org.apache.hive.service.cli.SessionHandle;
 import org.apache.hive.service.cli.TableSchema;
+import org.apache.hive.service.cli.log.LogManager;
 import org.apache.hive.service.cli.operation.ExecuteStatementOperation;
 import org.apache.hive.service.cli.operation.GetCatalogsOperation;
 import org.apache.hive.service.cli.operation.GetColumnsOperation;
@@ -64,6 +64,7 @@ public class HiveSessionImpl implements HiveSession {
 
   private SessionManager sessionManager;
   private OperationManager operationManager;
+  private LogManager logManager;
   private IMetaStoreClient metastoreClient = null;
   private String ipAddress;
 
@@ -81,7 +82,7 @@ public class HiveSessionImpl implements HiveSession {
     sessionState = new SessionState(hiveConf);
   }
 
-  private SessionManager getSessionManager() {
+  public SessionManager getSessionManager() {
     return sessionManager;
   }
 
@@ -123,6 +124,14 @@ public class HiveSessionImpl implements HiveSession {
     return hiveConf;
   }
 
+  public LogManager getLogManager() {
+    return logManager;
+  }
+
+  public void setLogManager(LogManager logManager) {
+    this.logManager = logManager;
+  }
+
   public IMetaStoreClient getMetaStoreClient() throws HiveSQLException {
     if (metastoreClient == null) {
       try {
@@ -153,7 +162,7 @@ public class HiveSessionImpl implements HiveSession {
         return new GetInfoValue(128);
       case CLI_TXN_CAPABLE:
       default:
-        throw new HiveSQLException("Unrecognized GetInfoType value: " + getInfoType.toString());
+        throw new HiveSQLException("Unrecognized GetInfoType value: "  + getInfoType.toString());
       }
     } finally {
       release();
@@ -162,12 +171,21 @@ public class HiveSessionImpl implements HiveSession {
 
   public OperationHandle executeStatement(String statement, Map<String, String> confOverlay)
       throws HiveSQLException {
+    OperationHandle operationHandle;
     acquire();
     try {
       ExecuteStatementOperation operation = getOperationManager()
-          .newExecuteStatementOperation(getSession(), statement, confOverlay);
+          .newExecuteStatementOperation(this, statement, confOverlay);
+      //Log capture
+      getLogManager().unregisterCurrentThread();
+      operationHandle = operation.getHandle();
+      getLogManager().registerCurrentThread(operationHandle);
+
       operation.run();
-      return operation.getHandle();
+
+      // unregister the current thread after capturing the log
+      getLogManager().unregisterCurrentThread();
+      return operationHandle;
     } finally {
       release();
     }
@@ -175,23 +193,40 @@ public class HiveSessionImpl implements HiveSession {
 
   public OperationHandle getTypeInfo()
       throws HiveSQLException {
+    OperationHandle operationHandle;
     acquire();
     try {
-      GetTypeInfoOperation operation = getOperationManager().newGetTypeInfoOperation(getSession());
+      GetTypeInfoOperation operation = getOperationManager().newGetTypeInfoOperation(this);
+      getLogManager().unregisterCurrentThread();
+
+      //Log Capture
+      operationHandle = operation.getHandle();
+      getLogManager().registerCurrentThread(operationHandle);
       operation.run();
-      return operation.getHandle();
+
+      // unregister the current thread after capturing the log
+      getLogManager().unregisterCurrentThread();
+      return operationHandle;
     } finally {
       release();
     }
   }
 
-  public OperationHandle getCatalogs()
-      throws HiveSQLException {
+  public OperationHandle getCatalogs() throws HiveSQLException {
+    OperationHandle operationHandle;
     acquire();
     try {
-      GetCatalogsOperation operation = getOperationManager().newGetCatalogsOperation(getSession());
+      GetCatalogsOperation operation = getOperationManager().newGetCatalogsOperation(this);
+      getLogManager().unregisterCurrentThread();
+
+      //Log Capture
+      operationHandle = operation.getHandle();
+      getLogManager().registerCurrentThread(operationHandle);
       operation.run();
-      return operation.getHandle();
+
+      // unregister the current thread after capturing the log
+      getLogManager().unregisterCurrentThread();
+      return operationHandle;
     } finally {
       release();
     }
@@ -199,38 +234,60 @@ public class HiveSessionImpl implements HiveSession {
 
   public OperationHandle getSchemas(String catalogName, String schemaName)
       throws HiveSQLException {
-      acquire();
+    OperationHandle operationHandle;
+    acquire();
     try {
       GetSchemasOperation operation =
-          getOperationManager().newGetSchemasOperation(getSession(), catalogName, schemaName);
+          getOperationManager().newGetSchemasOperation(this, catalogName, schemaName);
+      getLogManager().unregisterCurrentThread();
+
+      //Log Capture
+      operationHandle = operation.getHandle();
+      getLogManager().registerCurrentThread(operationHandle);
       operation.run();
-      return operation.getHandle();
+
+      // unregister the current thread after capturing the log
+      getLogManager().unregisterCurrentThread();
+      return operationHandle;
     } finally {
       release();
     }
   }
 
   public OperationHandle getTables(String catalogName, String schemaName, String tableName,
-      List<String> tableTypes)
-      throws HiveSQLException {
-      acquire();
+      List<String> tableTypes) throws HiveSQLException {
+    OperationHandle operationHandle;
+    acquire();
     try {
       MetadataOperation operation =
-          getOperationManager().newGetTablesOperation(getSession(), catalogName, schemaName, tableName, tableTypes);
+        getOperationManager().newGetTablesOperation(this, catalogName, schemaName, tableName, tableTypes);
+      getLogManager().unregisterCurrentThread();
+
+      //Log Capture
+      operationHandle = operation.getHandle();
+      getLogManager().registerCurrentThread(operationHandle);
       operation.run();
-      return operation.getHandle();
+
+      // unregister the current thread after capturing the log
+      getLogManager().unregisterCurrentThread();
+      return operationHandle;
     } finally {
-      release();
+     release();
     }
   }
 
-  public OperationHandle getTableTypes()
-      throws HiveSQLException {
-      acquire();
+  public OperationHandle getTableTypes() throws HiveSQLException {
+    OperationHandle operationHandle;
+    acquire();
     try {
-      GetTableTypesOperation operation = getOperationManager().newGetTableTypesOperation(getSession());
+      GetTableTypesOperation operation = getOperationManager().newGetTableTypesOperation(this);
+      //Log Capture
+      operationHandle = operation.getHandle();
+      getLogManager().registerCurrentThread(operationHandle);
       operation.run();
-      return operation.getHandle();
+      // unregister the current thread after capturing the log
+      getLogManager().unregisterCurrentThread();
+      return operationHandle;
     } finally {
       release();
     }
@@ -238,12 +295,19 @@ public class HiveSessionImpl implements HiveSession {
 
   public OperationHandle getColumns(String catalogName, String schemaName,
       String tableName, String columnName)  throws HiveSQLException {
+        OperationHandle operationHandle;
     acquire();
     try {
-    GetColumnsOperation operation = getOperationManager().newGetColumnsOperation(getSession(),
+    GetColumnsOperation operation = getOperationManager().newGetColumnsOperation(this,
         catalogName, schemaName, tableName, columnName);
+    //Log Capture
+    operationHandle = operation.getHandle();
+    getLogManager().registerCurrentThread(operationHandle);
     operation.run();
-    return operation.getHandle();
+
+    // unregister the current thread after capturing the log
+    getLogManager().unregisterCurrentThread();
+    return operationHandle;
     } finally {
       release();
     }
@@ -251,12 +315,19 @@ public class HiveSessionImpl implements HiveSession {
 
   public OperationHandle getFunctions(String catalogName, String schemaName, String functionName)
       throws HiveSQLException {
+    OperationHandle operationHandle;
     acquire();
     try {
       GetFunctionsOperation operation = getOperationManager()
-          .newGetFunctionsOperation(getSession(), catalogName, schemaName, functionName);
+          .newGetFunctionsOperation(this, catalogName, schemaName, functionName);
+      //Log Capture
+      operationHandle = operation.getHandle();
+      getLogManager().registerCurrentThread(operationHandle);
       operation.run();
-      return operation.getHandle();
+
+      // unregister the current thread after capturing the log
+      getLogManager().unregisterCurrentThread();
+      return operationHandle;
     } finally {
       release();
     }
diff --git a/src/service/src/java/org/apache/hive/service/cli/session/HiveSessionImplwithUGI.java b/src/service/src/java/org/apache/hive/service/cli/session/HiveSessionImplwithUGI.java
index 13e30fc..f6125c0 100644
--- a/src/service/src/java/org/apache/hive/service/cli/session/HiveSessionImplwithUGI.java
+++ b/src/service/src/java/org/apache/hive/service/cli/session/HiveSessionImplwithUGI.java
@@ -162,6 +162,4 @@ public class HiveSessionImplwithUGI extends HiveSessionImpl {
   public void setProxySession(HiveSession proxySession) {
     this.proxySession = proxySession;
   }
-
-
 }
diff --git a/src/service/src/java/org/apache/hive/service/cli/session/SessionManager.java b/src/service/src/java/org/apache/hive/service/cli/session/SessionManager.java
index 1065ee3..8739b1d 100644
--- a/src/service/src/java/org/apache/hive/service/cli/session/SessionManager.java
+++ b/src/service/src/java/org/apache/hive/service/cli/session/SessionManager.java
@@ -25,6 +25,7 @@ import org.apache.hadoop.hive.conf.HiveConf;
 import org.apache.hive.service.CompositeService;
 import org.apache.hive.service.cli.HiveSQLException;
 import org.apache.hive.service.cli.SessionHandle;
+import org.apache.hive.service.cli.log.LogManager;
 import org.apache.hive.service.cli.operation.OperationManager;
 
 /**
@@ -36,6 +37,7 @@ public class SessionManager extends CompositeService {
   private HiveConf hiveConf;
   private final Map<SessionHandle, HiveSession> handleToSession = new HashMap<SessionHandle, HiveSession>();
   private OperationManager operationManager = new OperationManager();
+  private LogManager logManager = new LogManager();
   private static final Object sessionMapLock = new Object();
 
   public SessionManager() {
@@ -47,8 +49,14 @@ public class SessionManager extends CompositeService {
     this.hiveConf = hiveConf;
 
     operationManager = new OperationManager();
+    operationManager.setSessionManager(this);
     addService(operationManager);
 
+    logManager = new LogManager();
+    logManager.setSessionManager(this);
+
+    addService(logManager);
+
     super.init(hiveConf);
   }
 
@@ -82,6 +90,7 @@ public class SessionManager extends CompositeService {
 
     session.setSessionManager(this);
     session.setOperationManager(operationManager);
+    session.setLogManager(logManager);
     synchronized(sessionMapLock) {
       handleToSession.put(session.getSessionHandle(), session);
     }
@@ -115,6 +124,10 @@ public class SessionManager extends CompositeService {
     return operationManager;
   }
 
+  public LogManager getLogManager() {
+    return logManager;
+  }
+
   private static ThreadLocal<String> threadLocalIpAddress = new ThreadLocal<String>() {
     @Override
     protected synchronized String initialValue() {
diff --git a/src/service/src/java/org/apache/hive/service/cli/thrift/ThriftCLIService.java b/src/service/src/java/org/apache/hive/service/cli/thrift/ThriftCLIService.java
index 933e10a..4ac9feb 100644
--- a/src/service/src/java/org/apache/hive/service/cli/thrift/ThriftCLIService.java
+++ b/src/service/src/java/org/apache/hive/service/cli/thrift/ThriftCLIService.java
@@ -55,7 +55,6 @@ public class ThriftCLIService extends AbstractService implements TCLIService.Ifa
 
   public static final Log LOG = LogFactory.getLog(ThriftCLIService.class.getName());
 
-
   protected CLIService cliService;
   private static final TStatus OK_STATUS = new TStatus(TStatusCode.SUCCESS_STATUS);
   private static final TStatus ERROR_STATUS = new TStatus(TStatusCode.ERROR_STATUS);
@@ -384,6 +383,20 @@ public class ThriftCLIService extends AbstractService implements TCLIService.Ifa
     return resp;
   }
 
+  @Override
+  public TGetLogResp GetLog(TGetLogReq req) throws TException {
+    TGetLogResp resp = new TGetLogResp();
+    try {
+      String log = cliService.getLog(new OperationHandle(req.getOperationHandle()));
+      resp.setStatus(OK_STATUS);
+      resp.setLog(log);
+    } catch (Exception e) {
+      e.printStackTrace();
+      resp.setStatus(HiveSQLException.toTStatus(e));
+    }
+    return resp;
+  }
+
 
   @Override
   public void run() {
@@ -432,4 +445,6 @@ public class ThriftCLIService extends AbstractService implements TCLIService.Ifa
     }
   }
 
+
+
 }
diff --git a/src/service/src/java/org/apache/hive/service/cli/thrift/ThriftCLIServiceClient.java b/src/service/src/java/org/apache/hive/service/cli/thrift/ThriftCLIServiceClient.java
index 5eb6157..c724086 100644
--- a/src/service/src/java/org/apache/hive/service/cli/thrift/ThriftCLIServiceClient.java
+++ b/src/service/src/java/org/apache/hive/service/cli/thrift/ThriftCLIServiceClient.java
@@ -370,4 +370,19 @@ public class ThriftCLIServiceClient extends CLIServiceClient {
     // TODO: set the correct default fetch size
     return fetchResults(opHandle, FetchOrientation.FETCH_NEXT, 10000);
   }
+
+  @Override
+  public String getLog(OperationHandle opHandle) throws HiveSQLException {
+    try {
+      TGetLogReq req = new TGetLogReq();
+      req.setOperationHandle(opHandle.toTOperationHandle());
+      TGetLogResp resp = cliService.GetLog(req);
+      checkStatus(resp.getStatus());
+      return new String(resp.getLog());
+    } catch (HiveSQLException e) {
+      throw e;
+    } catch (Exception e) {
+      throw new HiveSQLException(e);
+    }
+  }
 }
-- 
1.7.0.4

